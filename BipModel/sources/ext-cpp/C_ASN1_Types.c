/*
Code automatically generated by asn1scc tool
*/
#include <limits.h>
#include <string.h>
#include <math.h>
#include "C_ASN1_Types.h"

#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_LaserScan_ranges_Initialize(asn1SccBase_samples_LaserScan_ranges* pVal)
{
    *pVal = (asn1SccBase_samples_LaserScan_ranges) {    .nCount = 1,    .arr = 
    {
        0        
    }
};
}
#endif

 
flag asn1SccBase_samples_LaserScan_ranges_IsConstraintValid(const asn1SccBase_samples_LaserScan_ranges* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_samples_LaserScan_ranges);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_samples_LaserScan_ranges;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_UInt32_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}

flag asn1SccBase_samples_LaserScan_ranges_Encode(const asn1SccBase_samples_LaserScan_ranges* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? asn1SccBase_samples_LaserScan_ranges_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccT_UInt32_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag asn1SccBase_samples_LaserScan_ranges_Decode(asn1SccBase_samples_LaserScan_ranges* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : 268435457;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = asn1SccT_UInt32_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_Angle_Initialize(asn1SccBase_Angle* pVal)
{
    *pVal = (asn1SccBase_Angle) {
    .rad = 0.00000000000000000000E+000
};
}
#endif

 
flag asn1SccBase_Angle_IsConstraintValid(const asn1SccBase_Angle* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccT_Double_IsConstraintValid(&pVal->rad, pErrCode);


	return ret;
}

flag asn1SccBase_Angle_Encode(const asn1SccBase_Angle* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccBase_Angle_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode rad */
	    ret = asn1SccT_Double_Encode(&pVal->rad, pBitStrm, pErrCode, FALSE);

    }

	return ret;
}

flag asn1SccBase_Angle_Decode(asn1SccBase_Angle* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode rad */
	ret = asn1SccT_Double_Decode(&pVal->rad, pBitStrm, pErrCode);
	


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_commands_Motion2D_Initialize(asn1SccBase_commands_Motion2D* pVal)
{
    *pVal = (asn1SccBase_commands_Motion2D) {
    .translation = 0.00000000000000000000E+000,
    .rotation = 0.00000000000000000000E+000,
    .heading = {
        .rad = 0.00000000000000000000E+000
    }
};
}
#endif

 
flag asn1SccBase_commands_Motion2D_IsConstraintValid(const asn1SccBase_commands_Motion2D* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccT_Double_IsConstraintValid(&pVal->translation, pErrCode);
	if (ret) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->rotation, pErrCode);
	    if (ret) {
	        ret = asn1SccBase_Angle_IsConstraintValid(&pVal->heading, pErrCode);
	    
	    }
	}

	return ret;
}

flag asn1SccBase_commands_Motion2D_Encode(const asn1SccBase_commands_Motion2D* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccBase_commands_Motion2D_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode translation */
	    ret = asn1SccT_Double_Encode(&pVal->translation, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode rotation */
	        ret = asn1SccT_Double_Encode(&pVal->rotation, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode heading */
	            ret = asn1SccBase_Angle_Encode(&pVal->heading, pBitStrm, pErrCode, FALSE);
	        
	        }
	    }
    }

	return ret;
}

flag asn1SccBase_commands_Motion2D_Decode(asn1SccBase_commands_Motion2D* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode translation */
	ret = asn1SccT_Double_Decode(&pVal->translation, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode rotation */
	    ret = asn1SccT_Double_Decode(&pVal->rotation, pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode heading */
	        ret = asn1SccBase_Angle_Decode(&pVal->heading, pBitStrm, pErrCode);
	    
	    }
	}


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_Sonar_bearings_Initialize(asn1SccBase_samples_Sonar_bearings* pVal)
{
    *pVal = (asn1SccBase_samples_Sonar_bearings) {    .nCount = 1,    .arr = 
    {
        {
            .rad = 0.00000000000000000000E+000
        }        
    }
};
}
#endif

 
flag asn1SccBase_samples_Sonar_bearings_IsConstraintValid(const asn1SccBase_samples_Sonar_bearings* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_samples_Sonar_bearings);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_samples_Sonar_bearings;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccBase_Angle_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}

flag asn1SccBase_samples_Sonar_bearings_Encode(const asn1SccBase_samples_Sonar_bearings* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? asn1SccBase_samples_Sonar_bearings_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccBase_Angle_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag asn1SccBase_samples_Sonar_bearings_Decode(asn1SccBase_samples_Sonar_bearings* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : 268435458;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = asn1SccBase_Angle_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_PoseUpdateThreshold_Initialize(asn1SccBase_PoseUpdateThreshold* pVal)
{
    *pVal = (asn1SccBase_PoseUpdateThreshold) {
    .distance = 0.00000000000000000000E+000,
    .angle = 0.00000000000000000000E+000
};
}
#endif

 
flag asn1SccBase_PoseUpdateThreshold_IsConstraintValid(const asn1SccBase_PoseUpdateThreshold* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccT_Double_IsConstraintValid(&pVal->distance, pErrCode);
	if (ret) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->angle, pErrCode);
	
	}

	return ret;
}

flag asn1SccBase_PoseUpdateThreshold_Encode(const asn1SccBase_PoseUpdateThreshold* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccBase_PoseUpdateThreshold_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode distance */
	    ret = asn1SccT_Double_Encode(&pVal->distance, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode angle */
	        ret = asn1SccT_Double_Encode(&pVal->angle, pBitStrm, pErrCode, FALSE);
	    
	    }
    }

	return ret;
}

flag asn1SccBase_PoseUpdateThreshold_Decode(asn1SccBase_PoseUpdateThreshold* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode distance */
	ret = asn1SccT_Double_Decode(&pVal->distance, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode angle */
	    ret = asn1SccT_Double_Decode(&pVal->angle, pBitStrm, pErrCode);
	
	}


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_Temperature_Initialize(asn1SccBase_Temperature* pVal)
{
    *pVal = (asn1SccBase_Temperature) {
    .kelvin = 0.00000000000000000000E+000
};
}
#endif

 
flag asn1SccBase_Temperature_IsConstraintValid(const asn1SccBase_Temperature* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccT_Double_IsConstraintValid(&pVal->kelvin, pErrCode);


	return ret;
}

flag asn1SccBase_Temperature_Encode(const asn1SccBase_Temperature* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccBase_Temperature_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode kelvin */
	    ret = asn1SccT_Double_Encode(&pVal->kelvin, pBitStrm, pErrCode, FALSE);

    }

	return ret;
}

flag asn1SccBase_Temperature_Decode(asn1SccBase_Temperature* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode kelvin */
	ret = asn1SccT_Double_Decode(&pVal->kelvin, pBitStrm, pErrCode);
	


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_commands_Speed6D_Initialize(asn1SccBase_commands_Speed6D* pVal)
{
    *pVal = (asn1SccBase_commands_Speed6D) {
    .surge = 0.00000000000000000000E+000,
    .sway = 0.00000000000000000000E+000,
    .heave = 0.00000000000000000000E+000,
    .roll = 0.00000000000000000000E+000,
    .pitch = 0.00000000000000000000E+000,
    .yaw = 0.00000000000000000000E+000
};
}
#endif

 
flag asn1SccBase_commands_Speed6D_IsConstraintValid(const asn1SccBase_commands_Speed6D* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccT_Double_IsConstraintValid(&pVal->surge, pErrCode);
	if (ret) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->sway, pErrCode);
	    if (ret) {
	        ret = asn1SccT_Double_IsConstraintValid(&pVal->heave, pErrCode);
	        if (ret) {
	            ret = asn1SccT_Double_IsConstraintValid(&pVal->roll, pErrCode);
	            if (ret) {
	                ret = asn1SccT_Double_IsConstraintValid(&pVal->pitch, pErrCode);
	                if (ret) {
	                    ret = asn1SccT_Double_IsConstraintValid(&pVal->yaw, pErrCode);
	                
	                }
	            }
	        }
	    }
	}

	return ret;
}

flag asn1SccBase_commands_Speed6D_Encode(const asn1SccBase_commands_Speed6D* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccBase_commands_Speed6D_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode surge */
	    ret = asn1SccT_Double_Encode(&pVal->surge, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode sway */
	        ret = asn1SccT_Double_Encode(&pVal->sway, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode heave */
	            ret = asn1SccT_Double_Encode(&pVal->heave, pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode roll */
	                ret = asn1SccT_Double_Encode(&pVal->roll, pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode pitch */
	                    ret = asn1SccT_Double_Encode(&pVal->pitch, pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode yaw */
	                        ret = asn1SccT_Double_Encode(&pVal->yaw, pBitStrm, pErrCode, FALSE);
	                    
	                    }
	                }
	            }
	        }
	    }
    }

	return ret;
}

flag asn1SccBase_commands_Speed6D_Decode(asn1SccBase_commands_Speed6D* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode surge */
	ret = asn1SccT_Double_Decode(&pVal->surge, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode sway */
	    ret = asn1SccT_Double_Decode(&pVal->sway, pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode heave */
	        ret = asn1SccT_Double_Decode(&pVal->heave, pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode roll */
	            ret = asn1SccT_Double_Decode(&pVal->roll, pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode pitch */
	                ret = asn1SccT_Double_Decode(&pVal->pitch, pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode yaw */
	                    ret = asn1SccT_Double_Decode(&pVal->yaw, pBitStrm, pErrCode);
	                
	                }
	            }
	        }
	    }
	}


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccWrappers_geometry_Spline_vertices_Initialize(asn1SccWrappers_geometry_Spline_vertices* pVal)
{
    *pVal = (asn1SccWrappers_geometry_Spline_vertices) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccWrappers_geometry_Spline_vertices_IsConstraintValid(const asn1SccWrappers_geometry_Spline_vertices* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numWrappers_geometry_Spline_vertices);
	*pErrCode = ret ? 0 : ERR_asn1SccWrappers_geometry_Spline_vertices;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}

flag asn1SccWrappers_geometry_Spline_vertices_Encode(const asn1SccWrappers_geometry_Spline_vertices* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? asn1SccWrappers_geometry_Spline_vertices_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccT_Double_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag asn1SccWrappers_geometry_Spline_vertices_Decode(asn1SccWrappers_geometry_Spline_vertices* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : 268435459;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = asn1SccT_Double_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccWrappers_geometry_Spline_knots_Initialize(asn1SccWrappers_geometry_Spline_knots* pVal)
{
    *pVal = (asn1SccWrappers_geometry_Spline_knots) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccWrappers_geometry_Spline_knots_IsConstraintValid(const asn1SccWrappers_geometry_Spline_knots* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numWrappers_geometry_Spline_knots);
	*pErrCode = ret ? 0 : ERR_asn1SccWrappers_geometry_Spline_knots;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}

flag asn1SccWrappers_geometry_Spline_knots_Encode(const asn1SccWrappers_geometry_Spline_knots* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? asn1SccWrappers_geometry_Spline_knots_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccT_Double_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag asn1SccWrappers_geometry_Spline_knots_Decode(asn1SccWrappers_geometry_Spline_knots* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : 268435460;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = asn1SccT_Double_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccWrappers_VectorXd_data_Initialize(asn1SccWrappers_VectorXd_data* pVal)
{
    *pVal = (asn1SccWrappers_VectorXd_data) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccWrappers_VectorXd_data_IsConstraintValid(const asn1SccWrappers_VectorXd_data* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numWrappers_VectorXd_data);
	*pErrCode = ret ? 0 : ERR_asn1SccWrappers_VectorXd_data;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}

flag asn1SccWrappers_VectorXd_data_Encode(const asn1SccWrappers_VectorXd_data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? asn1SccWrappers_VectorXd_data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccT_Double_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag asn1SccWrappers_VectorXd_data_Decode(asn1SccWrappers_VectorXd_data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : 268435461;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = asn1SccT_Double_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccWrappers_VectorXd_Initialize(asn1SccWrappers_VectorXd* pVal)
{
    *pVal = (asn1SccWrappers_VectorXd) {
    .data = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    }
};
}
#endif

 
flag asn1SccWrappers_VectorXd_IsConstraintValid(const asn1SccWrappers_VectorXd* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccWrappers_VectorXd_data_IsConstraintValid(&pVal->data, pErrCode);


	return ret;
}

flag asn1SccWrappers_VectorXd_Encode(const asn1SccWrappers_VectorXd* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccWrappers_VectorXd_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode data */
	    ret = asn1SccWrappers_VectorXd_data_Encode(&pVal->data, pBitStrm, pErrCode, FALSE);

    }

	return ret;
}

flag asn1SccWrappers_VectorXd_Decode(asn1SccWrappers_VectorXd* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode data */
	ret = asn1SccWrappers_VectorXd_data_Decode(&pVal->data, pBitStrm, pErrCode);
	


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccWrappers_Quaterniond_im_Initialize(asn1SccWrappers_Quaterniond_im* pVal)
{
    *pVal = (asn1SccWrappers_Quaterniond_im) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccWrappers_Quaterniond_im_IsConstraintValid(const asn1SccWrappers_Quaterniond_im* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= 3);
	*pErrCode = ret ? 0 : ERR_asn1SccWrappers_Quaterniond_im;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}

flag asn1SccWrappers_Quaterniond_im_Encode(const asn1SccWrappers_Quaterniond_im* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? asn1SccWrappers_Quaterniond_im_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 3);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccT_Double_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag asn1SccWrappers_Quaterniond_im_Decode(asn1SccWrappers_Quaterniond_im* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	*pErrCode = ret ? 0 : 268435462;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = asn1SccT_Double_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccWrappers_Quaterniond_Initialize(asn1SccWrappers_Quaterniond* pVal)
{
    *pVal = (asn1SccWrappers_Quaterniond) {
    .im = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    },
    .re = 0.00000000000000000000E+000
};
}
#endif

 
flag asn1SccWrappers_Quaterniond_IsConstraintValid(const asn1SccWrappers_Quaterniond* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccWrappers_Quaterniond_im_IsConstraintValid(&pVal->im, pErrCode);
	if (ret) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->re, pErrCode);
	
	}

	return ret;
}

flag asn1SccWrappers_Quaterniond_Encode(const asn1SccWrappers_Quaterniond* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccWrappers_Quaterniond_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode im */
	    ret = asn1SccWrappers_Quaterniond_im_Encode(&pVal->im, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode re */
	        ret = asn1SccT_Double_Encode(&pVal->re, pBitStrm, pErrCode, FALSE);
	    
	    }
    }

	return ret;
}

flag asn1SccWrappers_Quaterniond_Decode(asn1SccWrappers_Quaterniond* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode im */
	ret = asn1SccWrappers_Quaterniond_im_Decode(&pVal->im, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode re */
	    ret = asn1SccT_Double_Decode(&pVal->re, pBitStrm, pErrCode);
	
	}


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccWrappers_MatrixXd_data_Initialize(asn1SccWrappers_MatrixXd_data* pVal)
{
    *pVal = (asn1SccWrappers_MatrixXd_data) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccWrappers_MatrixXd_data_IsConstraintValid(const asn1SccWrappers_MatrixXd_data* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numWrappers_MatrixXd_data);
	*pErrCode = ret ? 0 : ERR_asn1SccWrappers_MatrixXd_data;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}

flag asn1SccWrappers_MatrixXd_data_Encode(const asn1SccWrappers_MatrixXd_data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? asn1SccWrappers_MatrixXd_data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccT_Double_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag asn1SccWrappers_MatrixXd_data_Decode(asn1SccWrappers_MatrixXd_data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : 268435463;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = asn1SccT_Double_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccWrappers_MatrixXd_Initialize(asn1SccWrappers_MatrixXd* pVal)
{
    *pVal = (asn1SccWrappers_MatrixXd) {
    .rows = -2147483648LL,
    .cols = -2147483648LL,
    .data = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    }
};
}
#endif

 
flag asn1SccWrappers_MatrixXd_IsConstraintValid(const asn1SccWrappers_MatrixXd* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccT_Int32_IsConstraintValid(&pVal->rows, pErrCode);
	if (ret) {
	    ret = asn1SccT_Int32_IsConstraintValid(&pVal->cols, pErrCode);
	    if (ret) {
	        ret = asn1SccWrappers_MatrixXd_data_IsConstraintValid(&pVal->data, pErrCode);
	    
	    }
	}

	return ret;
}

flag asn1SccWrappers_MatrixXd_Encode(const asn1SccWrappers_MatrixXd* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccWrappers_MatrixXd_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode rows */
	    ret = asn1SccT_Int32_Encode(&pVal->rows, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode cols */
	        ret = asn1SccT_Int32_Encode(&pVal->cols, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode data */
	            ret = asn1SccWrappers_MatrixXd_data_Encode(&pVal->data, pBitStrm, pErrCode, FALSE);
	        
	        }
	    }
    }

	return ret;
}

flag asn1SccWrappers_MatrixXd_Decode(asn1SccWrappers_MatrixXd* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode rows */
	ret = asn1SccT_Int32_Decode(&pVal->rows, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode cols */
	    ret = asn1SccT_Int32_Decode(&pVal->cols, pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode data */
	        ret = asn1SccWrappers_MatrixXd_data_Decode(&pVal->data, pBitStrm, pErrCode);
	    
	    }
	}


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccWrappers_Matrix6d_data_Initialize(asn1SccWrappers_Matrix6d_data* pVal)
{
    *pVal = (asn1SccWrappers_Matrix6d_data) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccWrappers_Matrix6d_data_IsConstraintValid(const asn1SccWrappers_Matrix6d_data* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= 36);
	*pErrCode = ret ? 0 : ERR_asn1SccWrappers_Matrix6d_data;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}

flag asn1SccWrappers_Matrix6d_data_Encode(const asn1SccWrappers_Matrix6d_data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? asn1SccWrappers_Matrix6d_data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 36);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccT_Double_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag asn1SccWrappers_Matrix6d_data_Decode(asn1SccWrappers_Matrix6d_data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 36);
	*pErrCode = ret ? 0 : 268435464;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = asn1SccT_Double_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccWrappers_Matrix6d_Initialize(asn1SccWrappers_Matrix6d* pVal)
{
    *pVal = (asn1SccWrappers_Matrix6d) {
    .data = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    }
};
}
#endif

 
flag asn1SccWrappers_Matrix6d_IsConstraintValid(const asn1SccWrappers_Matrix6d* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccWrappers_Matrix6d_data_IsConstraintValid(&pVal->data, pErrCode);


	return ret;
}

flag asn1SccWrappers_Matrix6d_Encode(const asn1SccWrappers_Matrix6d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccWrappers_Matrix6d_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode data */
	    ret = asn1SccWrappers_Matrix6d_data_Encode(&pVal->data, pBitStrm, pErrCode, FALSE);

    }

	return ret;
}

flag asn1SccWrappers_Matrix6d_Decode(asn1SccWrappers_Matrix6d* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode data */
	ret = asn1SccWrappers_Matrix6d_data_Decode(&pVal->data, pBitStrm, pErrCode);
	


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccWrappers_Vector6d_data_Initialize(asn1SccWrappers_Vector6d_data* pVal)
{
    *pVal = (asn1SccWrappers_Vector6d_data) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccWrappers_Vector6d_data_IsConstraintValid(const asn1SccWrappers_Vector6d_data* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= 6);
	*pErrCode = ret ? 0 : ERR_asn1SccWrappers_Vector6d_data;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}

flag asn1SccWrappers_Vector6d_data_Encode(const asn1SccWrappers_Vector6d_data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? asn1SccWrappers_Vector6d_data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 6);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccT_Double_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag asn1SccWrappers_Vector6d_data_Decode(asn1SccWrappers_Vector6d_data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 6);
	*pErrCode = ret ? 0 : 268435465;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = asn1SccT_Double_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccWrappers_Vector6d_Initialize(asn1SccWrappers_Vector6d* pVal)
{
    *pVal = (asn1SccWrappers_Vector6d) {
    .data = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    }
};
}
#endif

 
flag asn1SccWrappers_Vector6d_IsConstraintValid(const asn1SccWrappers_Vector6d* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccWrappers_Vector6d_data_IsConstraintValid(&pVal->data, pErrCode);


	return ret;
}

flag asn1SccWrappers_Vector6d_Encode(const asn1SccWrappers_Vector6d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccWrappers_Vector6d_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode data */
	    ret = asn1SccWrappers_Vector6d_data_Encode(&pVal->data, pBitStrm, pErrCode, FALSE);

    }

	return ret;
}

flag asn1SccWrappers_Vector6d_Decode(asn1SccWrappers_Vector6d* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode data */
	ret = asn1SccWrappers_Vector6d_data_Decode(&pVal->data, pBitStrm, pErrCode);
	


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccWrappers_Matrix4d_data_Initialize(asn1SccWrappers_Matrix4d_data* pVal)
{
    *pVal = (asn1SccWrappers_Matrix4d_data) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccWrappers_Matrix4d_data_IsConstraintValid(const asn1SccWrappers_Matrix4d_data* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= 16);
	*pErrCode = ret ? 0 : ERR_asn1SccWrappers_Matrix4d_data;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}

flag asn1SccWrappers_Matrix4d_data_Encode(const asn1SccWrappers_Matrix4d_data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? asn1SccWrappers_Matrix4d_data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 16);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccT_Double_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag asn1SccWrappers_Matrix4d_data_Decode(asn1SccWrappers_Matrix4d_data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 16);
	*pErrCode = ret ? 0 : 268435466;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = asn1SccT_Double_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccWrappers_Matrix4d_Initialize(asn1SccWrappers_Matrix4d* pVal)
{
    *pVal = (asn1SccWrappers_Matrix4d) {
    .data = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    }
};
}
#endif

 
flag asn1SccWrappers_Matrix4d_IsConstraintValid(const asn1SccWrappers_Matrix4d* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccWrappers_Matrix4d_data_IsConstraintValid(&pVal->data, pErrCode);


	return ret;
}

flag asn1SccWrappers_Matrix4d_Encode(const asn1SccWrappers_Matrix4d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccWrappers_Matrix4d_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode data */
	    ret = asn1SccWrappers_Matrix4d_data_Encode(&pVal->data, pBitStrm, pErrCode, FALSE);

    }

	return ret;
}

flag asn1SccWrappers_Matrix4d_Decode(asn1SccWrappers_Matrix4d* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode data */
	ret = asn1SccWrappers_Matrix4d_data_Decode(&pVal->data, pBitStrm, pErrCode);
	


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccWrappers_Vector4d_data_Initialize(asn1SccWrappers_Vector4d_data* pVal)
{
    *pVal = (asn1SccWrappers_Vector4d_data) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccWrappers_Vector4d_data_IsConstraintValid(const asn1SccWrappers_Vector4d_data* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= 4);
	*pErrCode = ret ? 0 : ERR_asn1SccWrappers_Vector4d_data;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}

flag asn1SccWrappers_Vector4d_data_Encode(const asn1SccWrappers_Vector4d_data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? asn1SccWrappers_Vector4d_data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 4);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccT_Double_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag asn1SccWrappers_Vector4d_data_Decode(asn1SccWrappers_Vector4d_data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 4);
	*pErrCode = ret ? 0 : 268435467;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = asn1SccT_Double_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccWrappers_Vector4d_Initialize(asn1SccWrappers_Vector4d* pVal)
{
    *pVal = (asn1SccWrappers_Vector4d) {
    .data = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    }
};
}
#endif

 
flag asn1SccWrappers_Vector4d_IsConstraintValid(const asn1SccWrappers_Vector4d* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccWrappers_Vector4d_data_IsConstraintValid(&pVal->data, pErrCode);


	return ret;
}

flag asn1SccWrappers_Vector4d_Encode(const asn1SccWrappers_Vector4d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccWrappers_Vector4d_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode data */
	    ret = asn1SccWrappers_Vector4d_data_Encode(&pVal->data, pBitStrm, pErrCode, FALSE);

    }

	return ret;
}

flag asn1SccWrappers_Vector4d_Decode(asn1SccWrappers_Vector4d* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode data */
	ret = asn1SccWrappers_Vector4d_data_Decode(&pVal->data, pBitStrm, pErrCode);
	


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccStd_vector_Wrappers_Vector4d_Initialize(asn1SccStd_vector_Wrappers_Vector4d* pVal)
{
    *pVal = (asn1SccStd_vector_Wrappers_Vector4d) {    .nCount = 1,    .arr = 
    {
        {
            .data = {    .nCount = 1,    .arr = 
                {
                    0.00000000000000000000E+000        
                }
            }
        }        
    }
};
}
#endif

 
flag asn1SccStd_vector_Wrappers_Vector4d_IsConstraintValid(const asn1SccStd_vector_Wrappers_Vector4d* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numStd_vector_Wrappers_Vector4d);
	*pErrCode = ret ? 0 : ERR_asn1SccStd_vector_Wrappers_Vector4d;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccWrappers_Vector4d_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}

flag asn1SccStd_vector_Wrappers_Vector4d_Encode(const asn1SccStd_vector_Wrappers_Vector4d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? asn1SccStd_vector_Wrappers_Vector4d_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccWrappers_Vector4d_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag asn1SccStd_vector_Wrappers_Vector4d_Decode(asn1SccStd_vector_Wrappers_Vector4d* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : 268435468;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = asn1SccWrappers_Vector4d_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_Pointcloud_m_colors_Initialize(asn1SccBase_samples_Pointcloud_m_colors* pVal)
{
    *pVal = (asn1SccBase_samples_Pointcloud_m_colors) {    .nCount = 1,    .arr = 
    {
        {
            .data = {    .nCount = 1,    .arr = 
                {
                    0.00000000000000000000E+000        
                }
            }
        }        
    }
};
}
#endif

 
flag asn1SccBase_samples_Pointcloud_m_colors_IsConstraintValid(const asn1SccBase_samples_Pointcloud_m_colors* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_samples_Pointcloud_m_colors);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_samples_Pointcloud_m_colors;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccWrappers_Vector4d_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}

flag asn1SccBase_samples_Pointcloud_m_colors_Encode(const asn1SccBase_samples_Pointcloud_m_colors* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? asn1SccBase_samples_Pointcloud_m_colors_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccWrappers_Vector4d_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag asn1SccBase_samples_Pointcloud_m_colors_Decode(asn1SccBase_samples_Pointcloud_m_colors* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : 268435469;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = asn1SccWrappers_Vector4d_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_Pointcloud_colors_Initialize(asn1SccBase_samples_Pointcloud_colors* pVal)
{
    *pVal = (asn1SccBase_samples_Pointcloud_colors) {    .nCount = 1,    .arr = 
    {
        {
            .data = {    .nCount = 1,    .arr = 
                {
                    0.00000000000000000000E+000        
                }
            }
        }        
    }
};
}
#endif

 
flag asn1SccBase_samples_Pointcloud_colors_IsConstraintValid(const asn1SccBase_samples_Pointcloud_colors* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_samples_Pointcloud_colors);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_samples_Pointcloud_colors;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccWrappers_Vector4d_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}

flag asn1SccBase_samples_Pointcloud_colors_Encode(const asn1SccBase_samples_Pointcloud_colors* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? asn1SccBase_samples_Pointcloud_colors_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccWrappers_Vector4d_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag asn1SccBase_samples_Pointcloud_colors_Decode(asn1SccBase_samples_Pointcloud_colors* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : 268435470;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = asn1SccWrappers_Vector4d_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccWrappers_Matrix3d_data_Initialize(asn1SccWrappers_Matrix3d_data* pVal)
{
    *pVal = (asn1SccWrappers_Matrix3d_data) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccWrappers_Matrix3d_data_IsConstraintValid(const asn1SccWrappers_Matrix3d_data* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= 9);
	*pErrCode = ret ? 0 : ERR_asn1SccWrappers_Matrix3d_data;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}

flag asn1SccWrappers_Matrix3d_data_Encode(const asn1SccWrappers_Matrix3d_data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? asn1SccWrappers_Matrix3d_data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 9);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccT_Double_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag asn1SccWrappers_Matrix3d_data_Decode(asn1SccWrappers_Matrix3d_data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 9);
	*pErrCode = ret ? 0 : 268435471;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = asn1SccT_Double_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccWrappers_Matrix3d_Initialize(asn1SccWrappers_Matrix3d* pVal)
{
    *pVal = (asn1SccWrappers_Matrix3d) {
    .data = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    }
};
}
#endif

 
flag asn1SccWrappers_Matrix3d_IsConstraintValid(const asn1SccWrappers_Matrix3d* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccWrappers_Matrix3d_data_IsConstraintValid(&pVal->data, pErrCode);


	return ret;
}

flag asn1SccWrappers_Matrix3d_Encode(const asn1SccWrappers_Matrix3d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccWrappers_Matrix3d_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode data */
	    ret = asn1SccWrappers_Matrix3d_data_Encode(&pVal->data, pBitStrm, pErrCode, FALSE);

    }

	return ret;
}

flag asn1SccWrappers_Matrix3d_Decode(asn1SccWrappers_Matrix3d* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode data */
	ret = asn1SccWrappers_Matrix3d_data_Decode(&pVal->data, pBitStrm, pErrCode);
	


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccWrappers_Vector3d_data_Initialize(asn1SccWrappers_Vector3d_data* pVal)
{
    *pVal = (asn1SccWrappers_Vector3d_data) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccWrappers_Vector3d_data_IsConstraintValid(const asn1SccWrappers_Vector3d_data* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= 3);
	*pErrCode = ret ? 0 : ERR_asn1SccWrappers_Vector3d_data;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}

flag asn1SccWrappers_Vector3d_data_Encode(const asn1SccWrappers_Vector3d_data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? asn1SccWrappers_Vector3d_data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 3);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccT_Double_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag asn1SccWrappers_Vector3d_data_Decode(asn1SccWrappers_Vector3d_data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	*pErrCode = ret ? 0 : 268435472;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = asn1SccT_Double_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccWrappers_Vector3d_Initialize(asn1SccWrappers_Vector3d* pVal)
{
    *pVal = (asn1SccWrappers_Vector3d) {
    .data = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    }
};
}
#endif

 
flag asn1SccWrappers_Vector3d_IsConstraintValid(const asn1SccWrappers_Vector3d* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccWrappers_Vector3d_data_IsConstraintValid(&pVal->data, pErrCode);


	return ret;
}

flag asn1SccWrappers_Vector3d_Encode(const asn1SccWrappers_Vector3d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccWrappers_Vector3d_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode data */
	    ret = asn1SccWrappers_Vector3d_data_Encode(&pVal->data, pBitStrm, pErrCode, FALSE);

    }

	return ret;
}

flag asn1SccWrappers_Vector3d_Decode(asn1SccWrappers_Vector3d* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode data */
	ret = asn1SccWrappers_Vector3d_data_Decode(&pVal->data, pBitStrm, pErrCode);
	


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_Pose_Initialize(asn1SccBase_Pose* pVal)
{
    *pVal = (asn1SccBase_Pose) {
    .position = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .orientation = {
        .im = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        },
        .re = 0.00000000000000000000E+000
    }
};
}
#endif

 
flag asn1SccBase_Pose_IsConstraintValid(const asn1SccBase_Pose* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->position, pErrCode);
	if (ret) {
	    ret = asn1SccWrappers_Quaterniond_IsConstraintValid(&pVal->orientation, pErrCode);
	
	}

	return ret;
}

flag asn1SccBase_Pose_Encode(const asn1SccBase_Pose* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccBase_Pose_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode position */
	    ret = asn1SccWrappers_Vector3d_Encode(&pVal->position, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode orientation */
	        ret = asn1SccWrappers_Quaterniond_Encode(&pVal->orientation, pBitStrm, pErrCode, FALSE);
	    
	    }
    }

	return ret;
}

flag asn1SccBase_Pose_Decode(asn1SccBase_Pose* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode position */
	ret = asn1SccWrappers_Vector3d_Decode(&pVal->position, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode orientation */
	    ret = asn1SccWrappers_Quaterniond_Decode(&pVal->orientation, pBitStrm, pErrCode);
	
	}


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_TransformWithCovariance_Initialize(asn1SccBase_TransformWithCovariance* pVal)
{
    *pVal = (asn1SccBase_TransformWithCovariance) {
    .translation = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .orientation = {
        .im = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        },
        .re = 0.00000000000000000000E+000
    },
    .cov = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    }
};
}
#endif

 
flag asn1SccBase_TransformWithCovariance_IsConstraintValid(const asn1SccBase_TransformWithCovariance* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->translation, pErrCode);
	if (ret) {
	    ret = asn1SccWrappers_Quaterniond_IsConstraintValid(&pVal->orientation, pErrCode);
	    if (ret) {
	        ret = asn1SccWrappers_Matrix6d_IsConstraintValid(&pVal->cov, pErrCode);
	    
	    }
	}

	return ret;
}

flag asn1SccBase_TransformWithCovariance_Encode(const asn1SccBase_TransformWithCovariance* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccBase_TransformWithCovariance_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode translation */
	    ret = asn1SccWrappers_Vector3d_Encode(&pVal->translation, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode orientation */
	        ret = asn1SccWrappers_Quaterniond_Encode(&pVal->orientation, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode cov */
	            ret = asn1SccWrappers_Matrix6d_Encode(&pVal->cov, pBitStrm, pErrCode, FALSE);
	        
	        }
	    }
    }

	return ret;
}

flag asn1SccBase_TransformWithCovariance_Decode(asn1SccBase_TransformWithCovariance* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode translation */
	ret = asn1SccWrappers_Vector3d_Decode(&pVal->translation, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode orientation */
	    ret = asn1SccWrappers_Quaterniond_Decode(&pVal->orientation, pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode cov */
	        ret = asn1SccWrappers_Matrix6d_Decode(&pVal->cov, pBitStrm, pErrCode);
	    
	    }
	}


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_TwistWithCovariance_Initialize(asn1SccBase_TwistWithCovariance* pVal)
{
    *pVal = (asn1SccBase_TwistWithCovariance) {
    .vel = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .rot = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .cov = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    }
};
}
#endif

 
flag asn1SccBase_TwistWithCovariance_IsConstraintValid(const asn1SccBase_TwistWithCovariance* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->vel, pErrCode);
	if (ret) {
	    ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->rot, pErrCode);
	    if (ret) {
	        ret = asn1SccWrappers_Matrix6d_IsConstraintValid(&pVal->cov, pErrCode);
	    
	    }
	}

	return ret;
}

flag asn1SccBase_TwistWithCovariance_Encode(const asn1SccBase_TwistWithCovariance* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccBase_TwistWithCovariance_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode vel */
	    ret = asn1SccWrappers_Vector3d_Encode(&pVal->vel, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode rot */
	        ret = asn1SccWrappers_Vector3d_Encode(&pVal->rot, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode cov */
	            ret = asn1SccWrappers_Matrix6d_Encode(&pVal->cov, pBitStrm, pErrCode, FALSE);
	        
	        }
	    }
    }

	return ret;
}

flag asn1SccBase_TwistWithCovariance_Decode(asn1SccBase_TwistWithCovariance* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode vel */
	ret = asn1SccWrappers_Vector3d_Decode(&pVal->vel, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode rot */
	    ret = asn1SccWrappers_Vector3d_Decode(&pVal->rot, pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode cov */
	        ret = asn1SccWrappers_Matrix6d_Decode(&pVal->cov, pBitStrm, pErrCode);
	    
	    }
	}


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_Wrench_Initialize(asn1SccBase_Wrench* pVal)
{
    *pVal = (asn1SccBase_Wrench) {
    .force = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .torque = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    }
};
}
#endif

 
flag asn1SccBase_Wrench_IsConstraintValid(const asn1SccBase_Wrench* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->force, pErrCode);
	if (ret) {
	    ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->torque, pErrCode);
	
	}

	return ret;
}

flag asn1SccBase_Wrench_Encode(const asn1SccBase_Wrench* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccBase_Wrench_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode force */
	    ret = asn1SccWrappers_Vector3d_Encode(&pVal->force, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode torque */
	        ret = asn1SccWrappers_Vector3d_Encode(&pVal->torque, pBitStrm, pErrCode, FALSE);
	    
	    }
    }

	return ret;
}

flag asn1SccBase_Wrench_Decode(asn1SccBase_Wrench* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode force */
	ret = asn1SccWrappers_Vector3d_Decode(&pVal->force, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode torque */
	    ret = asn1SccWrappers_Vector3d_Decode(&pVal->torque, pBitStrm, pErrCode);
	
	}


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_Wrenches_elements_Initialize(asn1SccBase_samples_Wrenches_elements* pVal)
{
    *pVal = (asn1SccBase_samples_Wrenches_elements) {    .nCount = 1,    .arr = 
    {
        {
            .force = {
                .data = {    .nCount = 1,    .arr = 
                    {
                        0.00000000000000000000E+000        
                    }
                }
            },
            .torque = {
                .data = {    .nCount = 1,    .arr = 
                    {
                        0.00000000000000000000E+000        
                    }
                }
            }
        }        
    }
};
}
#endif

 
flag asn1SccBase_samples_Wrenches_elements_IsConstraintValid(const asn1SccBase_samples_Wrenches_elements* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_samples_Wrenches_elements);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_samples_Wrenches_elements;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccBase_Wrench_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}

flag asn1SccBase_samples_Wrenches_elements_Encode(const asn1SccBase_samples_Wrenches_elements* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? asn1SccBase_samples_Wrenches_elements_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccBase_Wrench_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag asn1SccBase_samples_Wrenches_elements_Decode(asn1SccBase_samples_Wrenches_elements* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : 268435473;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = asn1SccBase_Wrench_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_NamedVector_Base_Wrench_elements_Initialize(asn1SccBase_NamedVector_Base_Wrench_elements* pVal)
{
    *pVal = (asn1SccBase_NamedVector_Base_Wrench_elements) {    .nCount = 1,    .arr = 
    {
        {
            .force = {
                .data = {    .nCount = 1,    .arr = 
                    {
                        0.00000000000000000000E+000        
                    }
                }
            },
            .torque = {
                .data = {    .nCount = 1,    .arr = 
                    {
                        0.00000000000000000000E+000        
                    }
                }
            }
        }        
    }
};
}
#endif

 
flag asn1SccBase_NamedVector_Base_Wrench_elements_IsConstraintValid(const asn1SccBase_NamedVector_Base_Wrench_elements* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_NamedVector_Base_Wrench_elements);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_NamedVector_Base_Wrench_elements;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccBase_Wrench_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}

flag asn1SccBase_NamedVector_Base_Wrench_elements_Encode(const asn1SccBase_NamedVector_Base_Wrench_elements* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? asn1SccBase_NamedVector_Base_Wrench_elements_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccBase_Wrench_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag asn1SccBase_NamedVector_Base_Wrench_elements_Decode(asn1SccBase_NamedVector_Base_Wrench_elements* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : 268435474;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = asn1SccBase_Wrench_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_Waypoint_Initialize(asn1SccBase_Waypoint* pVal)
{
    *pVal = (asn1SccBase_Waypoint) {
    .position = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .heading = 0.00000000000000000000E+000,
    .tol_position = 0.00000000000000000000E+000,
    .tol_heading = 0.00000000000000000000E+000
};
}
#endif

 
flag asn1SccBase_Waypoint_IsConstraintValid(const asn1SccBase_Waypoint* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->position, pErrCode);
	if (ret) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->heading, pErrCode);
	    if (ret) {
	        ret = asn1SccT_Double_IsConstraintValid(&pVal->tol_position, pErrCode);
	        if (ret) {
	            ret = asn1SccT_Double_IsConstraintValid(&pVal->tol_heading, pErrCode);
	        
	        }
	    }
	}

	return ret;
}

flag asn1SccBase_Waypoint_Encode(const asn1SccBase_Waypoint* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccBase_Waypoint_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode position */
	    ret = asn1SccWrappers_Vector3d_Encode(&pVal->position, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode heading */
	        ret = asn1SccT_Double_Encode(&pVal->heading, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode tol_position */
	            ret = asn1SccT_Double_Encode(&pVal->tol_position, pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode tol_heading */
	                ret = asn1SccT_Double_Encode(&pVal->tol_heading, pBitStrm, pErrCode, FALSE);
	            
	            }
	        }
	    }
    }

	return ret;
}

flag asn1SccBase_Waypoint_Decode(asn1SccBase_Waypoint* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode position */
	ret = asn1SccWrappers_Vector3d_Decode(&pVal->position, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode heading */
	    ret = asn1SccT_Double_Decode(&pVal->heading, pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode tol_position */
	        ret = asn1SccT_Double_Decode(&pVal->tol_position, pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode tol_heading */
	            ret = asn1SccT_Double_Decode(&pVal->tol_heading, pBitStrm, pErrCode);
	        
	        }
	    }
	}


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_Pose_m_Initialize(asn1SccBase_Pose_m* pVal)
{
    *pVal = (asn1SccBase_Pose_m) {
    .position = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .orientation = {
        .im = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        },
        .re = 0.00000000000000000000E+000
    }
};
}
#endif

 
flag asn1SccBase_Pose_m_IsConstraintValid(const asn1SccBase_Pose_m* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->position, pErrCode);
	if (ret) {
	    ret = asn1SccWrappers_Quaterniond_IsConstraintValid(&pVal->orientation, pErrCode);
	
	}

	return ret;
}

flag asn1SccBase_Pose_m_Encode(const asn1SccBase_Pose_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccBase_Pose_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode position */
	    ret = asn1SccWrappers_Vector3d_Encode(&pVal->position, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode orientation */
	        ret = asn1SccWrappers_Quaterniond_Encode(&pVal->orientation, pBitStrm, pErrCode, FALSE);
	    
	    }
    }

	return ret;
}

flag asn1SccBase_Pose_m_Decode(asn1SccBase_Pose_m* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode position */
	ret = asn1SccWrappers_Vector3d_Decode(&pVal->position, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode orientation */
	    ret = asn1SccWrappers_Quaterniond_Decode(&pVal->orientation, pBitStrm, pErrCode);
	
	}


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_TransformWithCovariance_m_Initialize(asn1SccBase_TransformWithCovariance_m* pVal)
{
    *pVal = (asn1SccBase_TransformWithCovariance_m) {
    .translation = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .orientation = {
        .im = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        },
        .re = 0.00000000000000000000E+000
    },
    .cov = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    }
};
}
#endif

 
flag asn1SccBase_TransformWithCovariance_m_IsConstraintValid(const asn1SccBase_TransformWithCovariance_m* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->translation, pErrCode);
	if (ret) {
	    ret = asn1SccWrappers_Quaterniond_IsConstraintValid(&pVal->orientation, pErrCode);
	    if (ret) {
	        ret = asn1SccWrappers_Matrix6d_IsConstraintValid(&pVal->cov, pErrCode);
	    
	    }
	}

	return ret;
}

flag asn1SccBase_TransformWithCovariance_m_Encode(const asn1SccBase_TransformWithCovariance_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccBase_TransformWithCovariance_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode translation */
	    ret = asn1SccWrappers_Vector3d_Encode(&pVal->translation, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode orientation */
	        ret = asn1SccWrappers_Quaterniond_Encode(&pVal->orientation, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode cov */
	            ret = asn1SccWrappers_Matrix6d_Encode(&pVal->cov, pBitStrm, pErrCode, FALSE);
	        
	        }
	    }
    }

	return ret;
}

flag asn1SccBase_TransformWithCovariance_m_Decode(asn1SccBase_TransformWithCovariance_m* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode translation */
	ret = asn1SccWrappers_Vector3d_Decode(&pVal->translation, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode orientation */
	    ret = asn1SccWrappers_Quaterniond_Decode(&pVal->orientation, pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode cov */
	        ret = asn1SccWrappers_Matrix6d_Decode(&pVal->cov, pBitStrm, pErrCode);
	    
	    }
	}


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_TwistWithCovariance_m_Initialize(asn1SccBase_TwistWithCovariance_m* pVal)
{
    *pVal = (asn1SccBase_TwistWithCovariance_m) {
    .vel = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .rot = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .cov = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    }
};
}
#endif

 
flag asn1SccBase_TwistWithCovariance_m_IsConstraintValid(const asn1SccBase_TwistWithCovariance_m* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->vel, pErrCode);
	if (ret) {
	    ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->rot, pErrCode);
	    if (ret) {
	        ret = asn1SccWrappers_Matrix6d_IsConstraintValid(&pVal->cov, pErrCode);
	    
	    }
	}

	return ret;
}

flag asn1SccBase_TwistWithCovariance_m_Encode(const asn1SccBase_TwistWithCovariance_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccBase_TwistWithCovariance_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode vel */
	    ret = asn1SccWrappers_Vector3d_Encode(&pVal->vel, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode rot */
	        ret = asn1SccWrappers_Vector3d_Encode(&pVal->rot, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode cov */
	            ret = asn1SccWrappers_Matrix6d_Encode(&pVal->cov, pBitStrm, pErrCode, FALSE);
	        
	        }
	    }
    }

	return ret;
}

flag asn1SccBase_TwistWithCovariance_m_Decode(asn1SccBase_TwistWithCovariance_m* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode vel */
	ret = asn1SccWrappers_Vector3d_Decode(&pVal->vel, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode rot */
	    ret = asn1SccWrappers_Vector3d_Decode(&pVal->rot, pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode cov */
	        ret = asn1SccWrappers_Matrix6d_Decode(&pVal->cov, pBitStrm, pErrCode);
	    
	    }
	}


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_Waypoint_m_Initialize(asn1SccBase_Waypoint_m* pVal)
{
    *pVal = (asn1SccBase_Waypoint_m) {
    .position = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .heading = 0.00000000000000000000E+000,
    .tol_position = 0.00000000000000000000E+000,
    .tol_heading = 0.00000000000000000000E+000
};
}
#endif

 
flag asn1SccBase_Waypoint_m_IsConstraintValid(const asn1SccBase_Waypoint_m* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->position, pErrCode);
	if (ret) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->heading, pErrCode);
	    if (ret) {
	        ret = asn1SccT_Double_IsConstraintValid(&pVal->tol_position, pErrCode);
	        if (ret) {
	            ret = asn1SccT_Double_IsConstraintValid(&pVal->tol_heading, pErrCode);
	        
	        }
	    }
	}

	return ret;
}

flag asn1SccBase_Waypoint_m_Encode(const asn1SccBase_Waypoint_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccBase_Waypoint_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode position */
	    ret = asn1SccWrappers_Vector3d_Encode(&pVal->position, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode heading */
	        ret = asn1SccT_Double_Encode(&pVal->heading, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode tol_position */
	            ret = asn1SccT_Double_Encode(&pVal->tol_position, pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode tol_heading */
	                ret = asn1SccT_Double_Encode(&pVal->tol_heading, pBitStrm, pErrCode, FALSE);
	            
	            }
	        }
	    }
    }

	return ret;
}

flag asn1SccBase_Waypoint_m_Decode(asn1SccBase_Waypoint_m* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode position */
	ret = asn1SccWrappers_Vector3d_Decode(&pVal->position, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode heading */
	    ret = asn1SccT_Double_Decode(&pVal->heading, pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode tol_position */
	        ret = asn1SccT_Double_Decode(&pVal->tol_position, pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode tol_heading */
	            ret = asn1SccT_Double_Decode(&pVal->tol_heading, pBitStrm, pErrCode);
	        
	        }
	    }
	}


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccStd_orogen_typekits_mtype_std_vector_base_Waypoint_Initialize(asn1SccStd_orogen_typekits_mtype_std_vector_base_Waypoint* pVal)
{
    *pVal = (asn1SccStd_orogen_typekits_mtype_std_vector_base_Waypoint) {    .nCount = 1,    .arr = 
    {
        {
            .position = {
                .data = {    .nCount = 1,    .arr = 
                    {
                        0.00000000000000000000E+000        
                    }
                }
            },
            .heading = 0.00000000000000000000E+000,
            .tol_position = 0.00000000000000000000E+000,
            .tol_heading = 0.00000000000000000000E+000
        }        
    }
};
}
#endif

 
flag asn1SccStd_orogen_typekits_mtype_std_vector_base_Waypoint_IsConstraintValid(const asn1SccStd_orogen_typekits_mtype_std_vector_base_Waypoint* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numStd_orogen_typekits_mtype_std_vector_base_Waypoint);
	*pErrCode = ret ? 0 : ERR_asn1SccStd_orogen_typekits_mtype_std_vector_base_Waypoint;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccBase_Waypoint_m_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}

flag asn1SccStd_orogen_typekits_mtype_std_vector_base_Waypoint_Encode(const asn1SccStd_orogen_typekits_mtype_std_vector_base_Waypoint* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? asn1SccStd_orogen_typekits_mtype_std_vector_base_Waypoint_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccBase_Waypoint_m_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag asn1SccStd_orogen_typekits_mtype_std_vector_base_Waypoint_Decode(asn1SccStd_orogen_typekits_mtype_std_vector_base_Waypoint* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : 268435475;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = asn1SccBase_Waypoint_m_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_Wrench_m_Initialize(asn1SccBase_Wrench_m* pVal)
{
    *pVal = (asn1SccBase_Wrench_m) {
    .force = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .torque = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    }
};
}
#endif

 
flag asn1SccBase_Wrench_m_IsConstraintValid(const asn1SccBase_Wrench_m* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->force, pErrCode);
	if (ret) {
	    ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->torque, pErrCode);
	
	}

	return ret;
}

flag asn1SccBase_Wrench_m_Encode(const asn1SccBase_Wrench_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccBase_Wrench_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode force */
	    ret = asn1SccWrappers_Vector3d_Encode(&pVal->force, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode torque */
	        ret = asn1SccWrappers_Vector3d_Encode(&pVal->torque, pBitStrm, pErrCode, FALSE);
	    
	    }
    }

	return ret;
}

flag asn1SccBase_Wrench_m_Decode(asn1SccBase_Wrench_m* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode force */
	ret = asn1SccWrappers_Vector3d_Decode(&pVal->force, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode torque */
	    ret = asn1SccWrappers_Vector3d_Decode(&pVal->torque, pBitStrm, pErrCode);
	
	}


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccStd_orogen_typekits_mtype_std_vector_base_Wrench_Initialize(asn1SccStd_orogen_typekits_mtype_std_vector_base_Wrench* pVal)
{
    *pVal = (asn1SccStd_orogen_typekits_mtype_std_vector_base_Wrench) {    .nCount = 1,    .arr = 
    {
        {
            .force = {
                .data = {    .nCount = 1,    .arr = 
                    {
                        0.00000000000000000000E+000        
                    }
                }
            },
            .torque = {
                .data = {    .nCount = 1,    .arr = 
                    {
                        0.00000000000000000000E+000        
                    }
                }
            }
        }        
    }
};
}
#endif

 
flag asn1SccStd_orogen_typekits_mtype_std_vector_base_Wrench_IsConstraintValid(const asn1SccStd_orogen_typekits_mtype_std_vector_base_Wrench* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numStd_orogen_typekits_mtype_std_vector_base_Wrench);
	*pErrCode = ret ? 0 : ERR_asn1SccStd_orogen_typekits_mtype_std_vector_base_Wrench;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccBase_Wrench_m_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}

flag asn1SccStd_orogen_typekits_mtype_std_vector_base_Wrench_Encode(const asn1SccStd_orogen_typekits_mtype_std_vector_base_Wrench* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? asn1SccStd_orogen_typekits_mtype_std_vector_base_Wrench_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccBase_Wrench_m_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag asn1SccStd_orogen_typekits_mtype_std_vector_base_Wrench_Decode(asn1SccStd_orogen_typekits_mtype_std_vector_base_Wrench* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : 268435476;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = asn1SccBase_Wrench_m_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_Pointcloud_m_points_Initialize(asn1SccBase_samples_Pointcloud_m_points* pVal)
{
    *pVal = (asn1SccBase_samples_Pointcloud_m_points) {    .nCount = 1,    .arr = 
    {
        {
            .data = {    .nCount = 1,    .arr = 
                {
                    0.00000000000000000000E+000        
                }
            }
        }        
    }
};
}
#endif

 
flag asn1SccBase_samples_Pointcloud_m_points_IsConstraintValid(const asn1SccBase_samples_Pointcloud_m_points* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_samples_Pointcloud_m_points);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_samples_Pointcloud_m_points;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}

flag asn1SccBase_samples_Pointcloud_m_points_Encode(const asn1SccBase_samples_Pointcloud_m_points* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? asn1SccBase_samples_Pointcloud_m_points_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccWrappers_Vector3d_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag asn1SccBase_samples_Pointcloud_m_points_Decode(asn1SccBase_samples_Pointcloud_m_points* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : 268435477;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = asn1SccWrappers_Vector3d_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_Pointcloud_points_Initialize(asn1SccBase_samples_Pointcloud_points* pVal)
{
    *pVal = (asn1SccBase_samples_Pointcloud_points) {    .nCount = 1,    .arr = 
    {
        {
            .data = {    .nCount = 1,    .arr = 
                {
                    0.00000000000000000000E+000        
                }
            }
        }        
    }
};
}
#endif

 
flag asn1SccBase_samples_Pointcloud_points_IsConstraintValid(const asn1SccBase_samples_Pointcloud_points* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_samples_Pointcloud_points);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_samples_Pointcloud_points;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}

flag asn1SccBase_samples_Pointcloud_points_Encode(const asn1SccBase_samples_Pointcloud_points* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? asn1SccBase_samples_Pointcloud_points_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccWrappers_Vector3d_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag asn1SccBase_samples_Pointcloud_points_Decode(asn1SccBase_samples_Pointcloud_points* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : 268435478;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = asn1SccWrappers_Vector3d_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccWrappers_Matrix2d_data_Initialize(asn1SccWrappers_Matrix2d_data* pVal)
{
    *pVal = (asn1SccWrappers_Matrix2d_data) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccWrappers_Matrix2d_data_IsConstraintValid(const asn1SccWrappers_Matrix2d_data* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= 4);
	*pErrCode = ret ? 0 : ERR_asn1SccWrappers_Matrix2d_data;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}

flag asn1SccWrappers_Matrix2d_data_Encode(const asn1SccWrappers_Matrix2d_data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? asn1SccWrappers_Matrix2d_data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 4);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccT_Double_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag asn1SccWrappers_Matrix2d_data_Decode(asn1SccWrappers_Matrix2d_data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 4);
	*pErrCode = ret ? 0 : 268435479;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = asn1SccT_Double_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccWrappers_Matrix2d_Initialize(asn1SccWrappers_Matrix2d* pVal)
{
    *pVal = (asn1SccWrappers_Matrix2d) {
    .data = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    }
};
}
#endif

 
flag asn1SccWrappers_Matrix2d_IsConstraintValid(const asn1SccWrappers_Matrix2d* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccWrappers_Matrix2d_data_IsConstraintValid(&pVal->data, pErrCode);


	return ret;
}

flag asn1SccWrappers_Matrix2d_Encode(const asn1SccWrappers_Matrix2d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccWrappers_Matrix2d_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode data */
	    ret = asn1SccWrappers_Matrix2d_data_Encode(&pVal->data, pBitStrm, pErrCode, FALSE);

    }

	return ret;
}

flag asn1SccWrappers_Matrix2d_Decode(asn1SccWrappers_Matrix2d* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode data */
	ret = asn1SccWrappers_Matrix2d_data_Decode(&pVal->data, pBitStrm, pErrCode);
	


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccWrappers_Vector2d_data_Initialize(asn1SccWrappers_Vector2d_data* pVal)
{
    *pVal = (asn1SccWrappers_Vector2d_data) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccWrappers_Vector2d_data_IsConstraintValid(const asn1SccWrappers_Vector2d_data* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= 2);
	*pErrCode = ret ? 0 : ERR_asn1SccWrappers_Vector2d_data;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}

flag asn1SccWrappers_Vector2d_data_Encode(const asn1SccWrappers_Vector2d_data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? asn1SccWrappers_Vector2d_data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 2);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccT_Double_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag asn1SccWrappers_Vector2d_data_Decode(asn1SccWrappers_Vector2d_data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 2);
	*pErrCode = ret ? 0 : 268435480;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = asn1SccT_Double_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccWrappers_Vector2d_Initialize(asn1SccWrappers_Vector2d* pVal)
{
    *pVal = (asn1SccWrappers_Vector2d) {
    .data = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    }
};
}
#endif

 
flag asn1SccWrappers_Vector2d_IsConstraintValid(const asn1SccWrappers_Vector2d* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccWrappers_Vector2d_data_IsConstraintValid(&pVal->data, pErrCode);


	return ret;
}

flag asn1SccWrappers_Vector2d_Encode(const asn1SccWrappers_Vector2d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccWrappers_Vector2d_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode data */
	    ret = asn1SccWrappers_Vector2d_data_Encode(&pVal->data, pBitStrm, pErrCode, FALSE);

    }

	return ret;
}

flag asn1SccWrappers_Vector2d_Decode(asn1SccWrappers_Vector2d* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode data */
	ret = asn1SccWrappers_Vector2d_data_Decode(&pVal->data, pBitStrm, pErrCode);
	


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_Pose2D_Initialize(asn1SccBase_Pose2D* pVal)
{
    *pVal = (asn1SccBase_Pose2D) {
    .position = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .orientation = 0.00000000000000000000E+000
};
}
#endif

 
flag asn1SccBase_Pose2D_IsConstraintValid(const asn1SccBase_Pose2D* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccWrappers_Vector2d_IsConstraintValid(&pVal->position, pErrCode);
	if (ret) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->orientation, pErrCode);
	
	}

	return ret;
}

flag asn1SccBase_Pose2D_Encode(const asn1SccBase_Pose2D* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccBase_Pose2D_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode position */
	    ret = asn1SccWrappers_Vector2d_Encode(&pVal->position, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode orientation */
	        ret = asn1SccT_Double_Encode(&pVal->orientation, pBitStrm, pErrCode, FALSE);
	    
	    }
    }

	return ret;
}

flag asn1SccBase_Pose2D_Decode(asn1SccBase_Pose2D* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode position */
	ret = asn1SccWrappers_Vector2d_Decode(&pVal->position, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode orientation */
	    ret = asn1SccT_Double_Decode(&pVal->orientation, pBitStrm, pErrCode);
	
	}


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_Pose2D_m_Initialize(asn1SccBase_Pose2D_m* pVal)
{
    *pVal = (asn1SccBase_Pose2D_m) {
    .position = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .orientation = 0.00000000000000000000E+000
};
}
#endif

 
flag asn1SccBase_Pose2D_m_IsConstraintValid(const asn1SccBase_Pose2D_m* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccWrappers_Vector2d_IsConstraintValid(&pVal->position, pErrCode);
	if (ret) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->orientation, pErrCode);
	
	}

	return ret;
}

flag asn1SccBase_Pose2D_m_Encode(const asn1SccBase_Pose2D_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccBase_Pose2D_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode position */
	    ret = asn1SccWrappers_Vector2d_Encode(&pVal->position, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode orientation */
	        ret = asn1SccT_Double_Encode(&pVal->orientation, pBitStrm, pErrCode, FALSE);
	    
	    }
    }

	return ret;
}

flag asn1SccBase_Pose2D_m_Decode(asn1SccBase_Pose2D_m* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode position */
	ret = asn1SccWrappers_Vector2d_Decode(&pVal->position, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode orientation */
	    ret = asn1SccT_Double_Decode(&pVal->orientation, pBitStrm, pErrCode);
	
	}


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccWrappers_AngleAxisd_axis_Initialize(asn1SccWrappers_AngleAxisd_axis* pVal)
{
    *pVal = (asn1SccWrappers_AngleAxisd_axis) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccWrappers_AngleAxisd_axis_IsConstraintValid(const asn1SccWrappers_AngleAxisd_axis* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= 3);
	*pErrCode = ret ? 0 : ERR_asn1SccWrappers_AngleAxisd_axis;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}

flag asn1SccWrappers_AngleAxisd_axis_Encode(const asn1SccWrappers_AngleAxisd_axis* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? asn1SccWrappers_AngleAxisd_axis_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 3);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccT_Double_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag asn1SccWrappers_AngleAxisd_axis_Decode(asn1SccWrappers_AngleAxisd_axis* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	*pErrCode = ret ? 0 : 268435481;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = asn1SccT_Double_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccWrappers_AngleAxisd_Initialize(asn1SccWrappers_AngleAxisd* pVal)
{
    *pVal = (asn1SccWrappers_AngleAxisd) {
    .angle = 0.00000000000000000000E+000,
    .axis = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    }
};
}
#endif

 
flag asn1SccWrappers_AngleAxisd_IsConstraintValid(const asn1SccWrappers_AngleAxisd* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccT_Double_IsConstraintValid(&pVal->angle, pErrCode);
	if (ret) {
	    ret = asn1SccWrappers_AngleAxisd_axis_IsConstraintValid(&pVal->axis, pErrCode);
	
	}

	return ret;
}

flag asn1SccWrappers_AngleAxisd_Encode(const asn1SccWrappers_AngleAxisd* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccWrappers_AngleAxisd_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode angle */
	    ret = asn1SccT_Double_Encode(&pVal->angle, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode axis */
	        ret = asn1SccWrappers_AngleAxisd_axis_Encode(&pVal->axis, pBitStrm, pErrCode, FALSE);
	    
	    }
    }

	return ret;
}

flag asn1SccWrappers_AngleAxisd_Decode(asn1SccWrappers_AngleAxisd* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode angle */
	ret = asn1SccT_Double_Decode(&pVal->angle, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode axis */
	    ret = asn1SccWrappers_AngleAxisd_axis_Decode(&pVal->axis, pBitStrm, pErrCode);
	
	}


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_DepthMap_horizontal_interval_Initialize(asn1SccBase_samples_DepthMap_horizontal_interval* pVal)
{
    *pVal = (asn1SccBase_samples_DepthMap_horizontal_interval) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccBase_samples_DepthMap_horizontal_interval_IsConstraintValid(const asn1SccBase_samples_DepthMap_horizontal_interval* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_samples_DepthMap_horizontal_interval);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_samples_DepthMap_horizontal_interval;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}

flag asn1SccBase_samples_DepthMap_horizontal_interval_Encode(const asn1SccBase_samples_DepthMap_horizontal_interval* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? asn1SccBase_samples_DepthMap_horizontal_interval_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccT_Double_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag asn1SccBase_samples_DepthMap_horizontal_interval_Decode(asn1SccBase_samples_DepthMap_horizontal_interval* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : 268435482;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = asn1SccT_Double_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_DepthMap_vertical_interval_Initialize(asn1SccBase_samples_DepthMap_vertical_interval* pVal)
{
    *pVal = (asn1SccBase_samples_DepthMap_vertical_interval) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccBase_samples_DepthMap_vertical_interval_IsConstraintValid(const asn1SccBase_samples_DepthMap_vertical_interval* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_samples_DepthMap_vertical_interval);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_samples_DepthMap_vertical_interval;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}

flag asn1SccBase_samples_DepthMap_vertical_interval_Encode(const asn1SccBase_samples_DepthMap_vertical_interval* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? asn1SccBase_samples_DepthMap_vertical_interval_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccT_Double_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag asn1SccBase_samples_DepthMap_vertical_interval_Decode(asn1SccBase_samples_DepthMap_vertical_interval* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : 268435483;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = asn1SccT_Double_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_JointState_Initialize(asn1SccBase_JointState* pVal)
{
    *pVal = (asn1SccBase_JointState) {
    .position = 0.00000000000000000000E+000,
    .speed = 0.00000000000000000000E+000,
    .effort = 0.00000000000000000000E+000,
    .raw = 0.00000000000000000000E+000,
    .acceleration = 0.00000000000000000000E+000
};
}
#endif

 
flag asn1SccBase_JointState_IsConstraintValid(const asn1SccBase_JointState* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccT_Double_IsConstraintValid(&pVal->position, pErrCode);
	if (ret) {
	    ret = asn1SccT_Float_IsConstraintValid(&pVal->speed, pErrCode);
	    if (ret) {
	        ret = asn1SccT_Float_IsConstraintValid(&pVal->effort, pErrCode);
	        if (ret) {
	            ret = asn1SccT_Float_IsConstraintValid(&pVal->raw, pErrCode);
	            if (ret) {
	                ret = asn1SccT_Float_IsConstraintValid(&pVal->acceleration, pErrCode);
	            
	            }
	        }
	    }
	}

	return ret;
}

flag asn1SccBase_JointState_Encode(const asn1SccBase_JointState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccBase_JointState_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode position */
	    ret = asn1SccT_Double_Encode(&pVal->position, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode speed */
	        ret = asn1SccT_Float_Encode(&pVal->speed, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode effort */
	            ret = asn1SccT_Float_Encode(&pVal->effort, pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode raw */
	                ret = asn1SccT_Float_Encode(&pVal->raw, pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode acceleration */
	                    ret = asn1SccT_Float_Encode(&pVal->acceleration, pBitStrm, pErrCode, FALSE);
	                
	                }
	            }
	        }
	    }
    }

	return ret;
}

flag asn1SccBase_JointState_Decode(asn1SccBase_JointState* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode position */
	ret = asn1SccT_Double_Decode(&pVal->position, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode speed */
	    ret = asn1SccT_Float_Decode(&pVal->speed, pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode effort */
	        ret = asn1SccT_Float_Decode(&pVal->effort, pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode raw */
	            ret = asn1SccT_Float_Decode(&pVal->raw, pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode acceleration */
	                ret = asn1SccT_Float_Decode(&pVal->acceleration, pBitStrm, pErrCode);
	            
	            }
	        }
	    }
	}


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_JointTrajectory_Initialize(asn1SccBase_JointTrajectory* pVal)
{
    *pVal = (asn1SccBase_JointTrajectory) {    .nCount = 1,    .arr = 
    {
        {
            .position = 0.00000000000000000000E+000,
            .speed = 0.00000000000000000000E+000,
            .effort = 0.00000000000000000000E+000,
            .raw = 0.00000000000000000000E+000,
            .acceleration = 0.00000000000000000000E+000
        }        
    }
};
}
#endif

 
flag asn1SccBase_JointTrajectory_IsConstraintValid(const asn1SccBase_JointTrajectory* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_JointTrajectory);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_JointTrajectory;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccBase_JointState_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}

flag asn1SccBase_JointTrajectory_Encode(const asn1SccBase_JointTrajectory* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? asn1SccBase_JointTrajectory_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccBase_JointState_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag asn1SccBase_JointTrajectory_Decode(asn1SccBase_JointTrajectory* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : 268435484;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = asn1SccBase_JointState_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_NamedVector_Base_JointTrajectory_elements_Initialize(asn1SccBase_NamedVector_Base_JointTrajectory_elements* pVal)
{
    *pVal = (asn1SccBase_NamedVector_Base_JointTrajectory_elements) {    .nCount = 1,    .arr = 
    {
        {    .nCount = 1,    .arr = 
            {
                {
                    .position = 0.00000000000000000000E+000,
                    .speed = 0.00000000000000000000E+000,
                    .effort = 0.00000000000000000000E+000,
                    .raw = 0.00000000000000000000E+000,
                    .acceleration = 0.00000000000000000000E+000
                }        
            }
        }        
    }
};
}
#endif

 
flag asn1SccBase_NamedVector_Base_JointTrajectory_elements_IsConstraintValid(const asn1SccBase_NamedVector_Base_JointTrajectory_elements* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_NamedVector_Base_JointTrajectory_elements);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_NamedVector_Base_JointTrajectory_elements;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccBase_JointTrajectory_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}

flag asn1SccBase_NamedVector_Base_JointTrajectory_elements_Encode(const asn1SccBase_NamedVector_Base_JointTrajectory_elements* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? asn1SccBase_NamedVector_Base_JointTrajectory_elements_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccBase_JointTrajectory_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag asn1SccBase_NamedVector_Base_JointTrajectory_elements_Decode(asn1SccBase_NamedVector_Base_JointTrajectory_elements* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : 268435485;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = asn1SccBase_JointTrajectory_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_JointsTrajectory_elements_Initialize(asn1SccBase_JointsTrajectory_elements* pVal)
{
    *pVal = (asn1SccBase_JointsTrajectory_elements) {    .nCount = 1,    .arr = 
    {
        {    .nCount = 1,    .arr = 
            {
                {
                    .position = 0.00000000000000000000E+000,
                    .speed = 0.00000000000000000000E+000,
                    .effort = 0.00000000000000000000E+000,
                    .raw = 0.00000000000000000000E+000,
                    .acceleration = 0.00000000000000000000E+000
                }        
            }
        }        
    }
};
}
#endif

 
flag asn1SccBase_JointsTrajectory_elements_IsConstraintValid(const asn1SccBase_JointsTrajectory_elements* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_JointsTrajectory_elements);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_JointsTrajectory_elements;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccBase_JointTrajectory_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}

flag asn1SccBase_JointsTrajectory_elements_Encode(const asn1SccBase_JointsTrajectory_elements* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? asn1SccBase_JointsTrajectory_elements_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccBase_JointTrajectory_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag asn1SccBase_JointsTrajectory_elements_Decode(asn1SccBase_JointsTrajectory_elements* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : 268435486;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = asn1SccBase_JointTrajectory_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_JointLimitRange_Initialize(asn1SccBase_JointLimitRange* pVal)
{
    *pVal = (asn1SccBase_JointLimitRange) {
    .min = {
        .position = 0.00000000000000000000E+000,
        .speed = 0.00000000000000000000E+000,
        .effort = 0.00000000000000000000E+000,
        .raw = 0.00000000000000000000E+000,
        .acceleration = 0.00000000000000000000E+000
    },
    .max = {
        .position = 0.00000000000000000000E+000,
        .speed = 0.00000000000000000000E+000,
        .effort = 0.00000000000000000000E+000,
        .raw = 0.00000000000000000000E+000,
        .acceleration = 0.00000000000000000000E+000
    }
};
}
#endif

 
flag asn1SccBase_JointLimitRange_IsConstraintValid(const asn1SccBase_JointLimitRange* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccBase_JointState_IsConstraintValid(&pVal->min, pErrCode);
	if (ret) {
	    ret = asn1SccBase_JointState_IsConstraintValid(&pVal->max, pErrCode);
	
	}

	return ret;
}

flag asn1SccBase_JointLimitRange_Encode(const asn1SccBase_JointLimitRange* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccBase_JointLimitRange_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode min */
	    ret = asn1SccBase_JointState_Encode(&pVal->min, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode max */
	        ret = asn1SccBase_JointState_Encode(&pVal->max, pBitStrm, pErrCode, FALSE);
	    
	    }
    }

	return ret;
}

flag asn1SccBase_JointLimitRange_Decode(asn1SccBase_JointLimitRange* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode min */
	ret = asn1SccBase_JointState_Decode(&pVal->min, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode max */
	    ret = asn1SccBase_JointState_Decode(&pVal->max, pBitStrm, pErrCode);
	
	}


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_NamedVector_Base_JointLimitRange_elements_Initialize(asn1SccBase_NamedVector_Base_JointLimitRange_elements* pVal)
{
    *pVal = (asn1SccBase_NamedVector_Base_JointLimitRange_elements) {    .nCount = 1,    .arr = 
    {
        {
            .min = {
                .position = 0.00000000000000000000E+000,
                .speed = 0.00000000000000000000E+000,
                .effort = 0.00000000000000000000E+000,
                .raw = 0.00000000000000000000E+000,
                .acceleration = 0.00000000000000000000E+000
            },
            .max = {
                .position = 0.00000000000000000000E+000,
                .speed = 0.00000000000000000000E+000,
                .effort = 0.00000000000000000000E+000,
                .raw = 0.00000000000000000000E+000,
                .acceleration = 0.00000000000000000000E+000
            }
        }        
    }
};
}
#endif

 
flag asn1SccBase_NamedVector_Base_JointLimitRange_elements_IsConstraintValid(const asn1SccBase_NamedVector_Base_JointLimitRange_elements* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_NamedVector_Base_JointLimitRange_elements);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_NamedVector_Base_JointLimitRange_elements;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccBase_JointLimitRange_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}

flag asn1SccBase_NamedVector_Base_JointLimitRange_elements_Encode(const asn1SccBase_NamedVector_Base_JointLimitRange_elements* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? asn1SccBase_NamedVector_Base_JointLimitRange_elements_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccBase_JointLimitRange_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag asn1SccBase_NamedVector_Base_JointLimitRange_elements_Decode(asn1SccBase_NamedVector_Base_JointLimitRange_elements* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : 268435487;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = asn1SccBase_JointLimitRange_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_JointLimits_elements_Initialize(asn1SccBase_JointLimits_elements* pVal)
{
    *pVal = (asn1SccBase_JointLimits_elements) {    .nCount = 1,    .arr = 
    {
        {
            .min = {
                .position = 0.00000000000000000000E+000,
                .speed = 0.00000000000000000000E+000,
                .effort = 0.00000000000000000000E+000,
                .raw = 0.00000000000000000000E+000,
                .acceleration = 0.00000000000000000000E+000
            },
            .max = {
                .position = 0.00000000000000000000E+000,
                .speed = 0.00000000000000000000E+000,
                .effort = 0.00000000000000000000E+000,
                .raw = 0.00000000000000000000E+000,
                .acceleration = 0.00000000000000000000E+000
            }
        }        
    }
};
}
#endif

 
flag asn1SccBase_JointLimits_elements_IsConstraintValid(const asn1SccBase_JointLimits_elements* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_JointLimits_elements);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_JointLimits_elements;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccBase_JointLimitRange_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}

flag asn1SccBase_JointLimits_elements_Encode(const asn1SccBase_JointLimits_elements* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? asn1SccBase_JointLimits_elements_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccBase_JointLimitRange_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag asn1SccBase_JointLimits_elements_Decode(asn1SccBase_JointLimits_elements* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : 268435488;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = asn1SccBase_JointLimitRange_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_Pressure_Initialize(asn1SccBase_Pressure* pVal)
{
    *pVal = (asn1SccBase_Pressure) {
    .pascal = 0.00000000000000000000E+000
};
}
#endif

 
flag asn1SccBase_Pressure_IsConstraintValid(const asn1SccBase_Pressure* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccT_Float_IsConstraintValid(&pVal->pascal, pErrCode);


	return ret;
}

flag asn1SccBase_Pressure_Encode(const asn1SccBase_Pressure* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccBase_Pressure_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode pascal */
	    ret = asn1SccT_Float_Encode(&pVal->pascal, pBitStrm, pErrCode, FALSE);

    }

	return ret;
}

flag asn1SccBase_Pressure_Decode(asn1SccBase_Pressure* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode pascal */
	ret = asn1SccT_Float_Decode(&pVal->pascal, pBitStrm, pErrCode);
	


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_Sonar_bins_Initialize(asn1SccBase_samples_Sonar_bins* pVal)
{
    *pVal = (asn1SccBase_samples_Sonar_bins) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccBase_samples_Sonar_bins_IsConstraintValid(const asn1SccBase_samples_Sonar_bins* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_samples_Sonar_bins);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_samples_Sonar_bins;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Float_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}

flag asn1SccBase_samples_Sonar_bins_Encode(const asn1SccBase_samples_Sonar_bins* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? asn1SccBase_samples_Sonar_bins_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccT_Float_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag asn1SccBase_samples_Sonar_bins_Decode(asn1SccBase_samples_Sonar_bins* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : 268435489;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = asn1SccT_Float_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_LaserScan_remission_Initialize(asn1SccBase_samples_LaserScan_remission* pVal)
{
    *pVal = (asn1SccBase_samples_LaserScan_remission) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccBase_samples_LaserScan_remission_IsConstraintValid(const asn1SccBase_samples_LaserScan_remission* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_samples_LaserScan_remission);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_samples_LaserScan_remission;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Float_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}

flag asn1SccBase_samples_LaserScan_remission_Encode(const asn1SccBase_samples_LaserScan_remission* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? asn1SccBase_samples_LaserScan_remission_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccT_Float_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag asn1SccBase_samples_LaserScan_remission_Decode(asn1SccBase_samples_LaserScan_remission* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : 268435490;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = asn1SccT_Float_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_DistanceImage_data_Initialize(asn1SccBase_samples_DistanceImage_data* pVal)
{
    *pVal = (asn1SccBase_samples_DistanceImage_data) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccBase_samples_DistanceImage_data_IsConstraintValid(const asn1SccBase_samples_DistanceImage_data* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_samples_DistanceImage_data);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_samples_DistanceImage_data;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Float_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}

flag asn1SccBase_samples_DistanceImage_data_Encode(const asn1SccBase_samples_DistanceImage_data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? asn1SccBase_samples_DistanceImage_data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccT_Float_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag asn1SccBase_samples_DistanceImage_data_Decode(asn1SccBase_samples_DistanceImage_data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : 268435491;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = asn1SccT_Float_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_DepthMap_remissions_Initialize(asn1SccBase_samples_DepthMap_remissions* pVal)
{
    *pVal = (asn1SccBase_samples_DepthMap_remissions) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccBase_samples_DepthMap_remissions_IsConstraintValid(const asn1SccBase_samples_DepthMap_remissions* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_samples_DepthMap_remissions);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_samples_DepthMap_remissions;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Float_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}

flag asn1SccBase_samples_DepthMap_remissions_Encode(const asn1SccBase_samples_DepthMap_remissions* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? asn1SccBase_samples_DepthMap_remissions_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccT_Float_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag asn1SccBase_samples_DepthMap_remissions_Decode(asn1SccBase_samples_DepthMap_remissions* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : 268435492;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = asn1SccT_Float_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_DepthMap_distances_Initialize(asn1SccBase_samples_DepthMap_distances* pVal)
{
    *pVal = (asn1SccBase_samples_DepthMap_distances) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccBase_samples_DepthMap_distances_IsConstraintValid(const asn1SccBase_samples_DepthMap_distances* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_samples_DepthMap_distances);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_samples_DepthMap_distances;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Float_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}

flag asn1SccBase_samples_DepthMap_distances_Encode(const asn1SccBase_samples_DepthMap_distances* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? asn1SccBase_samples_DepthMap_distances_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccT_Float_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag asn1SccBase_samples_DepthMap_distances_Decode(asn1SccBase_samples_DepthMap_distances* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : 268435493;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = asn1SccT_Float_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_Time_Initialize(asn1SccBase_Time* pVal)
{
    *pVal = (asn1SccBase_Time) {
    .microseconds = -9223372036854775807LL
};
}
#endif

 
flag asn1SccBase_Time_IsConstraintValid(const asn1SccBase_Time* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccT_Int64_IsConstraintValid(&pVal->microseconds, pErrCode);


	return ret;
}

flag asn1SccBase_Time_Encode(const asn1SccBase_Time* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccBase_Time_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode microseconds */
	    ret = asn1SccT_Int64_Encode(&pVal->microseconds, pBitStrm, pErrCode, FALSE);

    }

	return ret;
}

flag asn1SccBase_Time_Decode(asn1SccBase_Time* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode microseconds */
	ret = asn1SccT_Int64_Decode(&pVal->microseconds, pBitStrm, pErrCode);
	


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_TimeStamped_Base_commands_Motion2D_Initialize(asn1SccBase_TimeStamped_Base_commands_Motion2D* pVal)
{
    *pVal = (asn1SccBase_TimeStamped_Base_commands_Motion2D) {
    .translation = 0.00000000000000000000E+000,
    .rotation = 0.00000000000000000000E+000,
    .heading = {
        .rad = 0.00000000000000000000E+000
    },
    .time = {
        .microseconds = -9223372036854775807LL
    }
};
}
#endif

 
flag asn1SccBase_TimeStamped_Base_commands_Motion2D_IsConstraintValid(const asn1SccBase_TimeStamped_Base_commands_Motion2D* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccT_Double_IsConstraintValid(&pVal->translation, pErrCode);
	if (ret) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->rotation, pErrCode);
	    if (ret) {
	        ret = asn1SccBase_Angle_IsConstraintValid(&pVal->heading, pErrCode);
	        if (ret) {
	            ret = asn1SccBase_Time_IsConstraintValid(&pVal->time, pErrCode);
	        
	        }
	    }
	}

	return ret;
}

flag asn1SccBase_TimeStamped_Base_commands_Motion2D_Encode(const asn1SccBase_TimeStamped_Base_commands_Motion2D* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccBase_TimeStamped_Base_commands_Motion2D_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode translation */
	    ret = asn1SccT_Double_Encode(&pVal->translation, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode rotation */
	        ret = asn1SccT_Double_Encode(&pVal->rotation, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode heading */
	            ret = asn1SccBase_Angle_Encode(&pVal->heading, pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode time */
	                ret = asn1SccBase_Time_Encode(&pVal->time, pBitStrm, pErrCode, FALSE);
	            
	            }
	        }
	    }
    }

	return ret;
}

flag asn1SccBase_TimeStamped_Base_commands_Motion2D_Decode(asn1SccBase_TimeStamped_Base_commands_Motion2D* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode translation */
	ret = asn1SccT_Double_Decode(&pVal->translation, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode rotation */
	    ret = asn1SccT_Double_Decode(&pVal->rotation, pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode heading */
	        ret = asn1SccBase_Angle_Decode(&pVal->heading, pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode time */
	            ret = asn1SccBase_Time_Decode(&pVal->time, pBitStrm, pErrCode);
	        
	        }
	    }
	}


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_LinearAngular6DCommand_Initialize(asn1SccBase_LinearAngular6DCommand* pVal)
{
    *pVal = (asn1SccBase_LinearAngular6DCommand) {
    .time = {
        .microseconds = -9223372036854775807LL
    },
    .linear = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .angular = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    }
};
}
#endif

 
flag asn1SccBase_LinearAngular6DCommand_IsConstraintValid(const asn1SccBase_LinearAngular6DCommand* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccBase_Time_IsConstraintValid(&pVal->time, pErrCode);
	if (ret) {
	    ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->linear, pErrCode);
	    if (ret) {
	        ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->angular, pErrCode);
	    
	    }
	}

	return ret;
}

flag asn1SccBase_LinearAngular6DCommand_Encode(const asn1SccBase_LinearAngular6DCommand* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccBase_LinearAngular6DCommand_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode time */
	    ret = asn1SccBase_Time_Encode(&pVal->time, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode linear */
	        ret = asn1SccWrappers_Vector3d_Encode(&pVal->linear, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode angular */
	            ret = asn1SccWrappers_Vector3d_Encode(&pVal->angular, pBitStrm, pErrCode, FALSE);
	        
	        }
	    }
    }

	return ret;
}

flag asn1SccBase_LinearAngular6DCommand_Decode(asn1SccBase_LinearAngular6DCommand* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode time */
	ret = asn1SccBase_Time_Decode(&pVal->time, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode linear */
	    ret = asn1SccWrappers_Vector3d_Decode(&pVal->linear, pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode angular */
	        ret = asn1SccWrappers_Vector3d_Decode(&pVal->angular, pBitStrm, pErrCode);
	    
	    }
	}


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_BodyState_Initialize(asn1SccBase_samples_BodyState* pVal)
{
    *pVal = (asn1SccBase_samples_BodyState) {
    .time = {
        .microseconds = -9223372036854775807LL
    },
    .pose = {
        .translation = {
            .data = {    .nCount = 1,    .arr = 
                {
                    0.00000000000000000000E+000        
                }
            }
        },
        .orientation = {
            .im = {    .nCount = 1,    .arr = 
                {
                    0.00000000000000000000E+000        
                }
            },
            .re = 0.00000000000000000000E+000
        },
        .cov = {
            .data = {    .nCount = 1,    .arr = 
                {
                    0.00000000000000000000E+000        
                }
            }
        }
    },
    .velocity = {
        .vel = {
            .data = {    .nCount = 1,    .arr = 
                {
                    0.00000000000000000000E+000        
                }
            }
        },
        .rot = {
            .data = {    .nCount = 1,    .arr = 
                {
                    0.00000000000000000000E+000        
                }
            }
        },
        .cov = {
            .data = {    .nCount = 1,    .arr = 
                {
                    0.00000000000000000000E+000        
                }
            }
        }
    }
};
}
#endif

 
flag asn1SccBase_samples_BodyState_IsConstraintValid(const asn1SccBase_samples_BodyState* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccBase_Time_IsConstraintValid(&pVal->time, pErrCode);
	if (ret) {
	    ret = asn1SccBase_TransformWithCovariance_IsConstraintValid(&pVal->pose, pErrCode);
	    if (ret) {
	        ret = asn1SccBase_TwistWithCovariance_IsConstraintValid(&pVal->velocity, pErrCode);
	    
	    }
	}

	return ret;
}

flag asn1SccBase_samples_BodyState_Encode(const asn1SccBase_samples_BodyState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccBase_samples_BodyState_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode time */
	    ret = asn1SccBase_Time_Encode(&pVal->time, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode pose */
	        ret = asn1SccBase_TransformWithCovariance_Encode(&pVal->pose, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode velocity */
	            ret = asn1SccBase_TwistWithCovariance_Encode(&pVal->velocity, pBitStrm, pErrCode, FALSE);
	        
	        }
	    }
    }

	return ret;
}

flag asn1SccBase_samples_BodyState_Decode(asn1SccBase_samples_BodyState* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode time */
	ret = asn1SccBase_Time_Decode(&pVal->time, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode pose */
	    ret = asn1SccBase_TransformWithCovariance_Decode(&pVal->pose, pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode velocity */
	        ret = asn1SccBase_TwistWithCovariance_Decode(&pVal->velocity, pBitStrm, pErrCode);
	    
	    }
	}


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_IMUSensors_Initialize(asn1SccBase_samples_IMUSensors* pVal)
{
    *pVal = (asn1SccBase_samples_IMUSensors) {
    .time = {
        .microseconds = -9223372036854775807LL
    },
    .acc = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .gyro = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .mag = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    }
};
}
#endif

 
flag asn1SccBase_samples_IMUSensors_IsConstraintValid(const asn1SccBase_samples_IMUSensors* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccBase_Time_IsConstraintValid(&pVal->time, pErrCode);
	if (ret) {
	    ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->acc, pErrCode);
	    if (ret) {
	        ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->gyro, pErrCode);
	        if (ret) {
	            ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->mag, pErrCode);
	        
	        }
	    }
	}

	return ret;
}

flag asn1SccBase_samples_IMUSensors_Encode(const asn1SccBase_samples_IMUSensors* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccBase_samples_IMUSensors_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode time */
	    ret = asn1SccBase_Time_Encode(&pVal->time, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode acc */
	        ret = asn1SccWrappers_Vector3d_Encode(&pVal->acc, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode gyro */
	            ret = asn1SccWrappers_Vector3d_Encode(&pVal->gyro, pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode mag */
	                ret = asn1SccWrappers_Vector3d_Encode(&pVal->mag, pBitStrm, pErrCode, FALSE);
	            
	            }
	        }
	    }
    }

	return ret;
}

flag asn1SccBase_samples_IMUSensors_Decode(asn1SccBase_samples_IMUSensors* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode time */
	ret = asn1SccBase_Time_Decode(&pVal->time, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode acc */
	    ret = asn1SccWrappers_Vector3d_Decode(&pVal->acc, pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode gyro */
	        ret = asn1SccWrappers_Vector3d_Decode(&pVal->gyro, pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode mag */
	            ret = asn1SccWrappers_Vector3d_Decode(&pVal->mag, pBitStrm, pErrCode);
	        
	        }
	    }
	}


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_Motion2D_Initialize(asn1SccBase_samples_Motion2D* pVal)
{
    *pVal = (asn1SccBase_samples_Motion2D) {
    .translation = 0.00000000000000000000E+000,
    .rotation = 0.00000000000000000000E+000,
    .heading = {
        .rad = 0.00000000000000000000E+000
    },
    .time = {
        .microseconds = -9223372036854775807LL
    }
};
}
#endif

 
flag asn1SccBase_samples_Motion2D_IsConstraintValid(const asn1SccBase_samples_Motion2D* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccT_Double_IsConstraintValid(&pVal->translation, pErrCode);
	if (ret) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->rotation, pErrCode);
	    if (ret) {
	        ret = asn1SccBase_Angle_IsConstraintValid(&pVal->heading, pErrCode);
	        if (ret) {
	            ret = asn1SccBase_Time_IsConstraintValid(&pVal->time, pErrCode);
	        
	        }
	    }
	}

	return ret;
}

flag asn1SccBase_samples_Motion2D_Encode(const asn1SccBase_samples_Motion2D* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccBase_samples_Motion2D_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode translation */
	    ret = asn1SccT_Double_Encode(&pVal->translation, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode rotation */
	        ret = asn1SccT_Double_Encode(&pVal->rotation, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode heading */
	            ret = asn1SccBase_Angle_Encode(&pVal->heading, pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode time */
	                ret = asn1SccBase_Time_Encode(&pVal->time, pBitStrm, pErrCode, FALSE);
	            
	            }
	        }
	    }
    }

	return ret;
}

flag asn1SccBase_samples_Motion2D_Decode(asn1SccBase_samples_Motion2D* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode translation */
	ret = asn1SccT_Double_Decode(&pVal->translation, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode rotation */
	    ret = asn1SccT_Double_Decode(&pVal->rotation, pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode heading */
	        ret = asn1SccBase_Angle_Decode(&pVal->heading, pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode time */
	            ret = asn1SccBase_Time_Decode(&pVal->time, pBitStrm, pErrCode);
	        
	        }
	    }
	}


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_Pressure_Initialize(asn1SccBase_samples_Pressure* pVal)
{
    *pVal = (asn1SccBase_samples_Pressure) {
    .pascal = 0.00000000000000000000E+000,
    .time = {
        .microseconds = -9223372036854775807LL
    }
};
}
#endif

 
flag asn1SccBase_samples_Pressure_IsConstraintValid(const asn1SccBase_samples_Pressure* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccT_Float_IsConstraintValid(&pVal->pascal, pErrCode);
	if (ret) {
	    ret = asn1SccBase_Time_IsConstraintValid(&pVal->time, pErrCode);
	
	}

	return ret;
}

flag asn1SccBase_samples_Pressure_Encode(const asn1SccBase_samples_Pressure* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccBase_samples_Pressure_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode pascal */
	    ret = asn1SccT_Float_Encode(&pVal->pascal, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode time */
	        ret = asn1SccBase_Time_Encode(&pVal->time, pBitStrm, pErrCode, FALSE);
	    
	    }
    }

	return ret;
}

flag asn1SccBase_samples_Pressure_Decode(asn1SccBase_samples_Pressure* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode pascal */
	ret = asn1SccT_Float_Decode(&pVal->pascal, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode time */
	    ret = asn1SccBase_Time_Decode(&pVal->time, pBitStrm, pErrCode);
	
	}


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_RigidBodyAcceleration_Initialize(asn1SccBase_samples_RigidBodyAcceleration* pVal)
{
    *pVal = (asn1SccBase_samples_RigidBodyAcceleration) {
    .time = {
        .microseconds = -9223372036854775807LL
    },
    .acceleration = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .cov_acceleration = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .angular_acceleration = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .cov_angular_acceleration = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    }
};
}
#endif

 
flag asn1SccBase_samples_RigidBodyAcceleration_IsConstraintValid(const asn1SccBase_samples_RigidBodyAcceleration* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccBase_Time_IsConstraintValid(&pVal->time, pErrCode);
	if (ret) {
	    ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->acceleration, pErrCode);
	    if (ret) {
	        ret = asn1SccWrappers_Matrix3d_IsConstraintValid(&pVal->cov_acceleration, pErrCode);
	        if (ret) {
	            ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->angular_acceleration, pErrCode);
	            if (ret) {
	                ret = asn1SccWrappers_Matrix3d_IsConstraintValid(&pVal->cov_angular_acceleration, pErrCode);
	            
	            }
	        }
	    }
	}

	return ret;
}

flag asn1SccBase_samples_RigidBodyAcceleration_Encode(const asn1SccBase_samples_RigidBodyAcceleration* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccBase_samples_RigidBodyAcceleration_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode time */
	    ret = asn1SccBase_Time_Encode(&pVal->time, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode acceleration */
	        ret = asn1SccWrappers_Vector3d_Encode(&pVal->acceleration, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode cov_acceleration */
	            ret = asn1SccWrappers_Matrix3d_Encode(&pVal->cov_acceleration, pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode angular_acceleration */
	                ret = asn1SccWrappers_Vector3d_Encode(&pVal->angular_acceleration, pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode cov_angular_acceleration */
	                    ret = asn1SccWrappers_Matrix3d_Encode(&pVal->cov_angular_acceleration, pBitStrm, pErrCode, FALSE);
	                
	                }
	            }
	        }
	    }
    }

	return ret;
}

flag asn1SccBase_samples_RigidBodyAcceleration_Decode(asn1SccBase_samples_RigidBodyAcceleration* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode time */
	ret = asn1SccBase_Time_Decode(&pVal->time, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode acceleration */
	    ret = asn1SccWrappers_Vector3d_Decode(&pVal->acceleration, pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode cov_acceleration */
	        ret = asn1SccWrappers_Matrix3d_Decode(&pVal->cov_acceleration, pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode angular_acceleration */
	            ret = asn1SccWrappers_Vector3d_Decode(&pVal->angular_acceleration, pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode cov_angular_acceleration */
	                ret = asn1SccWrappers_Matrix3d_Decode(&pVal->cov_angular_acceleration, pBitStrm, pErrCode);
	            
	            }
	        }
	    }
	}


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_Wrench_Initialize(asn1SccBase_samples_Wrench* pVal)
{
    *pVal = (asn1SccBase_samples_Wrench) {
    .force = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .torque = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .time = {
        .microseconds = -9223372036854775807LL
    }
};
}
#endif

 
flag asn1SccBase_samples_Wrench_IsConstraintValid(const asn1SccBase_samples_Wrench* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->force, pErrCode);
	if (ret) {
	    ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->torque, pErrCode);
	    if (ret) {
	        ret = asn1SccBase_Time_IsConstraintValid(&pVal->time, pErrCode);
	    
	    }
	}

	return ret;
}

flag asn1SccBase_samples_Wrench_Encode(const asn1SccBase_samples_Wrench* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccBase_samples_Wrench_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode force */
	    ret = asn1SccWrappers_Vector3d_Encode(&pVal->force, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode torque */
	        ret = asn1SccWrappers_Vector3d_Encode(&pVal->torque, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode time */
	            ret = asn1SccBase_Time_Encode(&pVal->time, pBitStrm, pErrCode, FALSE);
	        
	        }
	    }
    }

	return ret;
}

flag asn1SccBase_samples_Wrench_Decode(asn1SccBase_samples_Wrench* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode force */
	ret = asn1SccWrappers_Vector3d_Decode(&pVal->force, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode torque */
	    ret = asn1SccWrappers_Vector3d_Decode(&pVal->torque, pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode time */
	        ret = asn1SccBase_Time_Decode(&pVal->time, pBitStrm, pErrCode);
	    
	    }
	}


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_LaserScan_Initialize(asn1SccBase_samples_LaserScan* pVal)
{
    *pVal = (asn1SccBase_samples_LaserScan) {
    .time = {
        .microseconds = -9223372036854775807LL
    },
    .start_angle = 0.00000000000000000000E+000,
    .angular_resolution = 0.00000000000000000000E+000,
    .speed = 0.00000000000000000000E+000,
    .ranges = {    .nCount = 1,    .arr = 
        {
            0        
        }
    },
    .minrange = 0,
    .maxrange = 0,
    .remission = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    }
};
}
#endif

 
flag asn1SccBase_samples_LaserScan_IsConstraintValid(const asn1SccBase_samples_LaserScan* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccBase_Time_IsConstraintValid(&pVal->time, pErrCode);
	if (ret) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->start_angle, pErrCode);
	    if (ret) {
	        ret = asn1SccT_Double_IsConstraintValid(&pVal->angular_resolution, pErrCode);
	        if (ret) {
	            ret = asn1SccT_Double_IsConstraintValid(&pVal->speed, pErrCode);
	            if (ret) {
	                ret = asn1SccBase_samples_LaserScan_ranges_IsConstraintValid(&pVal->ranges, pErrCode);
	                if (ret) {
	                    ret = asn1SccT_UInt32_IsConstraintValid(&pVal->minrange, pErrCode);
	                    if (ret) {
	                        ret = asn1SccT_UInt32_IsConstraintValid(&pVal->maxrange, pErrCode);
	                        if (ret) {
	                            ret = asn1SccBase_samples_LaserScan_remission_IsConstraintValid(&pVal->remission, pErrCode);
	                        
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

	return ret;
}

flag asn1SccBase_samples_LaserScan_Encode(const asn1SccBase_samples_LaserScan* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccBase_samples_LaserScan_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode time */
	    ret = asn1SccBase_Time_Encode(&pVal->time, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode start_angle */
	        ret = asn1SccT_Double_Encode(&pVal->start_angle, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode angular_resolution */
	            ret = asn1SccT_Double_Encode(&pVal->angular_resolution, pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode speed */
	                ret = asn1SccT_Double_Encode(&pVal->speed, pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode ranges */
	                    ret = asn1SccBase_samples_LaserScan_ranges_Encode(&pVal->ranges, pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode minrange */
	                        ret = asn1SccT_UInt32_Encode(&pVal->minrange, pBitStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode maxrange */
	                            ret = asn1SccT_UInt32_Encode(&pVal->maxrange, pBitStrm, pErrCode, FALSE);
	                            if (ret) {
	                                /*Encode remission */
	                                ret = asn1SccBase_samples_LaserScan_remission_Encode(&pVal->remission, pBitStrm, pErrCode, FALSE);
	                            
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
    }

	return ret;
}

flag asn1SccBase_samples_LaserScan_Decode(asn1SccBase_samples_LaserScan* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode time */
	ret = asn1SccBase_Time_Decode(&pVal->time, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode start_angle */
	    ret = asn1SccT_Double_Decode(&pVal->start_angle, pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode angular_resolution */
	        ret = asn1SccT_Double_Decode(&pVal->angular_resolution, pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode speed */
	            ret = asn1SccT_Double_Decode(&pVal->speed, pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode ranges */
	                ret = asn1SccBase_samples_LaserScan_ranges_Decode(&pVal->ranges, pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode minrange */
	                    ret = asn1SccT_UInt32_Decode(&pVal->minrange, pBitStrm, pErrCode);
	                    if (ret) {
	                        /*Decode maxrange */
	                        ret = asn1SccT_UInt32_Decode(&pVal->maxrange, pBitStrm, pErrCode);
	                        if (ret) {
	                            /*Decode remission */
	                            ret = asn1SccBase_samples_LaserScan_remission_Decode(&pVal->remission, pBitStrm, pErrCode);
	                        
	                        }
	                    }
	                }
	            }
	        }
	    }
	}


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_Pointcloud_Initialize(asn1SccBase_samples_Pointcloud* pVal)
{
    *pVal = (asn1SccBase_samples_Pointcloud) {
    .time = {
        .microseconds = -9223372036854775807LL
    },
    .points = {    .nCount = 1,    .arr = 
        {
            {
                .data = {    .nCount = 1,    .arr = 
                    {
                        0.00000000000000000000E+000        
                    }
                }
            }        
        }
    },
    .colors = {    .nCount = 1,    .arr = 
        {
            {
                .data = {    .nCount = 1,    .arr = 
                    {
                        0.00000000000000000000E+000        
                    }
                }
            }        
        }
    }
};
}
#endif

 
flag asn1SccBase_samples_Pointcloud_IsConstraintValid(const asn1SccBase_samples_Pointcloud* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccBase_Time_IsConstraintValid(&pVal->time, pErrCode);
	if (ret) {
	    ret = asn1SccBase_samples_Pointcloud_points_IsConstraintValid(&pVal->points, pErrCode);
	    if (ret) {
	        ret = asn1SccBase_samples_Pointcloud_colors_IsConstraintValid(&pVal->colors, pErrCode);
	    
	    }
	}

	return ret;
}

flag asn1SccBase_samples_Pointcloud_Encode(const asn1SccBase_samples_Pointcloud* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccBase_samples_Pointcloud_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode time */
	    ret = asn1SccBase_Time_Encode(&pVal->time, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode points */
	        ret = asn1SccBase_samples_Pointcloud_points_Encode(&pVal->points, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode colors */
	            ret = asn1SccBase_samples_Pointcloud_colors_Encode(&pVal->colors, pBitStrm, pErrCode, FALSE);
	        
	        }
	    }
    }

	return ret;
}

flag asn1SccBase_samples_Pointcloud_Decode(asn1SccBase_samples_Pointcloud* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode time */
	ret = asn1SccBase_Time_Decode(&pVal->time, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode points */
	    ret = asn1SccBase_samples_Pointcloud_points_Decode(&pVal->points, pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode colors */
	        ret = asn1SccBase_samples_Pointcloud_colors_Decode(&pVal->colors, pBitStrm, pErrCode);
	    
	    }
	}


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_commands_LinearAngular6DCommand_m_Initialize(asn1SccBase_commands_LinearAngular6DCommand_m* pVal)
{
    *pVal = (asn1SccBase_commands_LinearAngular6DCommand_m) {
    .time = {
        .microseconds = -9223372036854775807LL
    },
    .linear = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .angular = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    }
};
}
#endif

 
flag asn1SccBase_commands_LinearAngular6DCommand_m_IsConstraintValid(const asn1SccBase_commands_LinearAngular6DCommand_m* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccBase_Time_IsConstraintValid(&pVal->time, pErrCode);
	if (ret) {
	    ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->linear, pErrCode);
	    if (ret) {
	        ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->angular, pErrCode);
	    
	    }
	}

	return ret;
}

flag asn1SccBase_commands_LinearAngular6DCommand_m_Encode(const asn1SccBase_commands_LinearAngular6DCommand_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccBase_commands_LinearAngular6DCommand_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode time */
	    ret = asn1SccBase_Time_Encode(&pVal->time, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode linear */
	        ret = asn1SccWrappers_Vector3d_Encode(&pVal->linear, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode angular */
	            ret = asn1SccWrappers_Vector3d_Encode(&pVal->angular, pBitStrm, pErrCode, FALSE);
	        
	        }
	    }
    }

	return ret;
}

flag asn1SccBase_commands_LinearAngular6DCommand_m_Decode(asn1SccBase_commands_LinearAngular6DCommand_m* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode time */
	ret = asn1SccBase_Time_Decode(&pVal->time, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode linear */
	    ret = asn1SccWrappers_Vector3d_Decode(&pVal->linear, pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode angular */
	        ret = asn1SccWrappers_Vector3d_Decode(&pVal->angular, pBitStrm, pErrCode);
	    
	    }
	}


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_BodyState_m_Initialize(asn1SccBase_samples_BodyState_m* pVal)
{
    *pVal = (asn1SccBase_samples_BodyState_m) {
    .time = {
        .microseconds = -9223372036854775807LL
    },
    .pose = {
        .translation = {
            .data = {    .nCount = 1,    .arr = 
                {
                    0.00000000000000000000E+000        
                }
            }
        },
        .orientation = {
            .im = {    .nCount = 1,    .arr = 
                {
                    0.00000000000000000000E+000        
                }
            },
            .re = 0.00000000000000000000E+000
        },
        .cov = {
            .data = {    .nCount = 1,    .arr = 
                {
                    0.00000000000000000000E+000        
                }
            }
        }
    },
    .velocity = {
        .vel = {
            .data = {    .nCount = 1,    .arr = 
                {
                    0.00000000000000000000E+000        
                }
            }
        },
        .rot = {
            .data = {    .nCount = 1,    .arr = 
                {
                    0.00000000000000000000E+000        
                }
            }
        },
        .cov = {
            .data = {    .nCount = 1,    .arr = 
                {
                    0.00000000000000000000E+000        
                }
            }
        }
    }
};
}
#endif

 
flag asn1SccBase_samples_BodyState_m_IsConstraintValid(const asn1SccBase_samples_BodyState_m* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccBase_Time_IsConstraintValid(&pVal->time, pErrCode);
	if (ret) {
	    ret = asn1SccBase_TransformWithCovariance_m_IsConstraintValid(&pVal->pose, pErrCode);
	    if (ret) {
	        ret = asn1SccBase_TwistWithCovariance_m_IsConstraintValid(&pVal->velocity, pErrCode);
	    
	    }
	}

	return ret;
}

flag asn1SccBase_samples_BodyState_m_Encode(const asn1SccBase_samples_BodyState_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccBase_samples_BodyState_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode time */
	    ret = asn1SccBase_Time_Encode(&pVal->time, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode pose */
	        ret = asn1SccBase_TransformWithCovariance_m_Encode(&pVal->pose, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode velocity */
	            ret = asn1SccBase_TwistWithCovariance_m_Encode(&pVal->velocity, pBitStrm, pErrCode, FALSE);
	        
	        }
	    }
    }

	return ret;
}

flag asn1SccBase_samples_BodyState_m_Decode(asn1SccBase_samples_BodyState_m* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode time */
	ret = asn1SccBase_Time_Decode(&pVal->time, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode pose */
	    ret = asn1SccBase_TransformWithCovariance_m_Decode(&pVal->pose, pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode velocity */
	        ret = asn1SccBase_TwistWithCovariance_m_Decode(&pVal->velocity, pBitStrm, pErrCode);
	    
	    }
	}


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_IMUSensors_m_Initialize(asn1SccBase_samples_IMUSensors_m* pVal)
{
    *pVal = (asn1SccBase_samples_IMUSensors_m) {
    .time = {
        .microseconds = -9223372036854775807LL
    },
    .acc = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .gyro = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .mag = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    }
};
}
#endif

 
flag asn1SccBase_samples_IMUSensors_m_IsConstraintValid(const asn1SccBase_samples_IMUSensors_m* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccBase_Time_IsConstraintValid(&pVal->time, pErrCode);
	if (ret) {
	    ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->acc, pErrCode);
	    if (ret) {
	        ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->gyro, pErrCode);
	        if (ret) {
	            ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->mag, pErrCode);
	        
	        }
	    }
	}

	return ret;
}

flag asn1SccBase_samples_IMUSensors_m_Encode(const asn1SccBase_samples_IMUSensors_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccBase_samples_IMUSensors_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode time */
	    ret = asn1SccBase_Time_Encode(&pVal->time, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode acc */
	        ret = asn1SccWrappers_Vector3d_Encode(&pVal->acc, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode gyro */
	            ret = asn1SccWrappers_Vector3d_Encode(&pVal->gyro, pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode mag */
	                ret = asn1SccWrappers_Vector3d_Encode(&pVal->mag, pBitStrm, pErrCode, FALSE);
	            
	            }
	        }
	    }
    }

	return ret;
}

flag asn1SccBase_samples_IMUSensors_m_Decode(asn1SccBase_samples_IMUSensors_m* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode time */
	ret = asn1SccBase_Time_Decode(&pVal->time, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode acc */
	    ret = asn1SccWrappers_Vector3d_Decode(&pVal->acc, pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode gyro */
	        ret = asn1SccWrappers_Vector3d_Decode(&pVal->gyro, pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode mag */
	            ret = asn1SccWrappers_Vector3d_Decode(&pVal->mag, pBitStrm, pErrCode);
	        
	        }
	    }
	}


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_RigidBodyAcceleration_m_Initialize(asn1SccBase_samples_RigidBodyAcceleration_m* pVal)
{
    *pVal = (asn1SccBase_samples_RigidBodyAcceleration_m) {
    .time = {
        .microseconds = -9223372036854775807LL
    },
    .acceleration = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .cov_acceleration = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .angular_acceleration = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .cov_angular_acceleration = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    }
};
}
#endif

 
flag asn1SccBase_samples_RigidBodyAcceleration_m_IsConstraintValid(const asn1SccBase_samples_RigidBodyAcceleration_m* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccBase_Time_IsConstraintValid(&pVal->time, pErrCode);
	if (ret) {
	    ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->acceleration, pErrCode);
	    if (ret) {
	        ret = asn1SccWrappers_Matrix3d_IsConstraintValid(&pVal->cov_acceleration, pErrCode);
	        if (ret) {
	            ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->angular_acceleration, pErrCode);
	            if (ret) {
	                ret = asn1SccWrappers_Matrix3d_IsConstraintValid(&pVal->cov_angular_acceleration, pErrCode);
	            
	            }
	        }
	    }
	}

	return ret;
}

flag asn1SccBase_samples_RigidBodyAcceleration_m_Encode(const asn1SccBase_samples_RigidBodyAcceleration_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccBase_samples_RigidBodyAcceleration_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode time */
	    ret = asn1SccBase_Time_Encode(&pVal->time, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode acceleration */
	        ret = asn1SccWrappers_Vector3d_Encode(&pVal->acceleration, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode cov_acceleration */
	            ret = asn1SccWrappers_Matrix3d_Encode(&pVal->cov_acceleration, pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode angular_acceleration */
	                ret = asn1SccWrappers_Vector3d_Encode(&pVal->angular_acceleration, pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode cov_angular_acceleration */
	                    ret = asn1SccWrappers_Matrix3d_Encode(&pVal->cov_angular_acceleration, pBitStrm, pErrCode, FALSE);
	                
	                }
	            }
	        }
	    }
    }

	return ret;
}

flag asn1SccBase_samples_RigidBodyAcceleration_m_Decode(asn1SccBase_samples_RigidBodyAcceleration_m* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode time */
	ret = asn1SccBase_Time_Decode(&pVal->time, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode acceleration */
	    ret = asn1SccWrappers_Vector3d_Decode(&pVal->acceleration, pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode cov_acceleration */
	        ret = asn1SccWrappers_Matrix3d_Decode(&pVal->cov_acceleration, pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode angular_acceleration */
	            ret = asn1SccWrappers_Vector3d_Decode(&pVal->angular_acceleration, pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode cov_angular_acceleration */
	                ret = asn1SccWrappers_Matrix3d_Decode(&pVal->cov_angular_acceleration, pBitStrm, pErrCode);
	            
	            }
	        }
	    }
	}


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_Wrench_m_Initialize(asn1SccBase_samples_Wrench_m* pVal)
{
    *pVal = (asn1SccBase_samples_Wrench_m) {
    .force = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .torque = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .time = {
        .microseconds = -9223372036854775807LL
    }
};
}
#endif

 
flag asn1SccBase_samples_Wrench_m_IsConstraintValid(const asn1SccBase_samples_Wrench_m* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->force, pErrCode);
	if (ret) {
	    ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->torque, pErrCode);
	    if (ret) {
	        ret = asn1SccBase_Time_IsConstraintValid(&pVal->time, pErrCode);
	    
	    }
	}

	return ret;
}

flag asn1SccBase_samples_Wrench_m_Encode(const asn1SccBase_samples_Wrench_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccBase_samples_Wrench_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode force */
	    ret = asn1SccWrappers_Vector3d_Encode(&pVal->force, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode torque */
	        ret = asn1SccWrappers_Vector3d_Encode(&pVal->torque, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode time */
	            ret = asn1SccBase_Time_Encode(&pVal->time, pBitStrm, pErrCode, FALSE);
	        
	        }
	    }
    }

	return ret;
}

flag asn1SccBase_samples_Wrench_m_Decode(asn1SccBase_samples_Wrench_m* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode force */
	ret = asn1SccWrappers_Vector3d_Decode(&pVal->force, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode torque */
	    ret = asn1SccWrappers_Vector3d_Decode(&pVal->torque, pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode time */
	        ret = asn1SccBase_Time_Decode(&pVal->time, pBitStrm, pErrCode);
	    
	    }
	}


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_Pointcloud_m_Initialize(asn1SccBase_samples_Pointcloud_m* pVal)
{
    *pVal = (asn1SccBase_samples_Pointcloud_m) {
    .time = {
        .microseconds = -9223372036854775807LL
    },
    .points = {    .nCount = 1,    .arr = 
        {
            {
                .data = {    .nCount = 1,    .arr = 
                    {
                        0.00000000000000000000E+000        
                    }
                }
            }        
        }
    },
    .colors = {    .nCount = 1,    .arr = 
        {
            {
                .data = {    .nCount = 1,    .arr = 
                    {
                        0.00000000000000000000E+000        
                    }
                }
            }        
        }
    }
};
}
#endif

 
flag asn1SccBase_samples_Pointcloud_m_IsConstraintValid(const asn1SccBase_samples_Pointcloud_m* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccBase_Time_IsConstraintValid(&pVal->time, pErrCode);
	if (ret) {
	    ret = asn1SccBase_samples_Pointcloud_m_points_IsConstraintValid(&pVal->points, pErrCode);
	    if (ret) {
	        ret = asn1SccBase_samples_Pointcloud_m_colors_IsConstraintValid(&pVal->colors, pErrCode);
	    
	    }
	}

	return ret;
}

flag asn1SccBase_samples_Pointcloud_m_Encode(const asn1SccBase_samples_Pointcloud_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccBase_samples_Pointcloud_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode time */
	    ret = asn1SccBase_Time_Encode(&pVal->time, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode points */
	        ret = asn1SccBase_samples_Pointcloud_m_points_Encode(&pVal->points, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode colors */
	            ret = asn1SccBase_samples_Pointcloud_m_colors_Encode(&pVal->colors, pBitStrm, pErrCode, FALSE);
	        
	        }
	    }
    }

	return ret;
}

flag asn1SccBase_samples_Pointcloud_m_Decode(asn1SccBase_samples_Pointcloud_m* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode time */
	ret = asn1SccBase_Time_Decode(&pVal->time, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode points */
	    ret = asn1SccBase_samples_Pointcloud_m_points_Decode(&pVal->points, pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode colors */
	        ret = asn1SccBase_samples_Pointcloud_m_colors_Decode(&pVal->colors, pBitStrm, pErrCode);
	    
	    }
	}


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_SonarScan_time_beams_Initialize(asn1SccBase_samples_SonarScan_time_beams* pVal)
{
    *pVal = (asn1SccBase_samples_SonarScan_time_beams) {    .nCount = 1,    .arr = 
    {
        {
            .microseconds = -9223372036854775807LL
        }        
    }
};
}
#endif

 
flag asn1SccBase_samples_SonarScan_time_beams_IsConstraintValid(const asn1SccBase_samples_SonarScan_time_beams* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_samples_SonarScan_time_beams);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_samples_SonarScan_time_beams;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccBase_Time_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}

flag asn1SccBase_samples_SonarScan_time_beams_Encode(const asn1SccBase_samples_SonarScan_time_beams* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? asn1SccBase_samples_SonarScan_time_beams_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccBase_Time_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag asn1SccBase_samples_SonarScan_time_beams_Decode(asn1SccBase_samples_SonarScan_time_beams* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : 268435494;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = asn1SccBase_Time_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_Sonar_timestamps_Initialize(asn1SccBase_samples_Sonar_timestamps* pVal)
{
    *pVal = (asn1SccBase_samples_Sonar_timestamps) {    .nCount = 1,    .arr = 
    {
        {
            .microseconds = -9223372036854775807LL
        }        
    }
};
}
#endif

 
flag asn1SccBase_samples_Sonar_timestamps_IsConstraintValid(const asn1SccBase_samples_Sonar_timestamps* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_samples_Sonar_timestamps);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_samples_Sonar_timestamps;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccBase_Time_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}

flag asn1SccBase_samples_Sonar_timestamps_Encode(const asn1SccBase_samples_Sonar_timestamps* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? asn1SccBase_samples_Sonar_timestamps_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccBase_Time_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag asn1SccBase_samples_Sonar_timestamps_Decode(asn1SccBase_samples_Sonar_timestamps* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : 268435495;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = asn1SccBase_Time_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_Sonar_Initialize(asn1SccBase_samples_Sonar* pVal)
{
    *pVal = (asn1SccBase_samples_Sonar) {
    .time = {
        .microseconds = -9223372036854775807LL
    },
    .timestamps = {    .nCount = 1,    .arr = 
        {
            {
                .microseconds = -9223372036854775807LL
            }        
        }
    },
    .bin_duration = {
        .microseconds = -9223372036854775807LL
    },
    .beam_width = {
        .rad = 0.00000000000000000000E+000
    },
    .beam_height = {
        .rad = 0.00000000000000000000E+000
    },
    .bearings = {    .nCount = 1,    .arr = 
        {
            {
                .rad = 0.00000000000000000000E+000
            }        
        }
    },
    .speed_of_sound = 0.00000000000000000000E+000,
    .bin_count = 0,
    .beam_count = 0,
    .bins = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    }
};
}
#endif

 
flag asn1SccBase_samples_Sonar_IsConstraintValid(const asn1SccBase_samples_Sonar* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccBase_Time_IsConstraintValid(&pVal->time, pErrCode);
	if (ret) {
	    ret = asn1SccBase_samples_Sonar_timestamps_IsConstraintValid(&pVal->timestamps, pErrCode);
	    if (ret) {
	        ret = asn1SccBase_Time_IsConstraintValid(&pVal->bin_duration, pErrCode);
	        if (ret) {
	            ret = asn1SccBase_Angle_IsConstraintValid(&pVal->beam_width, pErrCode);
	            if (ret) {
	                ret = asn1SccBase_Angle_IsConstraintValid(&pVal->beam_height, pErrCode);
	                if (ret) {
	                    ret = asn1SccBase_samples_Sonar_bearings_IsConstraintValid(&pVal->bearings, pErrCode);
	                    if (ret) {
	                        ret = asn1SccT_Float_IsConstraintValid(&pVal->speed_of_sound, pErrCode);
	                        if (ret) {
	                            ret = asn1SccT_UInt32_IsConstraintValid(&pVal->bin_count, pErrCode);
	                            if (ret) {
	                                ret = asn1SccT_UInt32_IsConstraintValid(&pVal->beam_count, pErrCode);
	                                if (ret) {
	                                    ret = asn1SccBase_samples_Sonar_bins_IsConstraintValid(&pVal->bins, pErrCode);
	                                
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

	return ret;
}

flag asn1SccBase_samples_Sonar_Encode(const asn1SccBase_samples_Sonar* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccBase_samples_Sonar_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode time */
	    ret = asn1SccBase_Time_Encode(&pVal->time, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode timestamps */
	        ret = asn1SccBase_samples_Sonar_timestamps_Encode(&pVal->timestamps, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode bin_duration */
	            ret = asn1SccBase_Time_Encode(&pVal->bin_duration, pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode beam_width */
	                ret = asn1SccBase_Angle_Encode(&pVal->beam_width, pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode beam_height */
	                    ret = asn1SccBase_Angle_Encode(&pVal->beam_height, pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode bearings */
	                        ret = asn1SccBase_samples_Sonar_bearings_Encode(&pVal->bearings, pBitStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode speed_of_sound */
	                            ret = asn1SccT_Float_Encode(&pVal->speed_of_sound, pBitStrm, pErrCode, FALSE);
	                            if (ret) {
	                                /*Encode bin_count */
	                                ret = asn1SccT_UInt32_Encode(&pVal->bin_count, pBitStrm, pErrCode, FALSE);
	                                if (ret) {
	                                    /*Encode beam_count */
	                                    ret = asn1SccT_UInt32_Encode(&pVal->beam_count, pBitStrm, pErrCode, FALSE);
	                                    if (ret) {
	                                        /*Encode bins */
	                                        ret = asn1SccBase_samples_Sonar_bins_Encode(&pVal->bins, pBitStrm, pErrCode, FALSE);
	                                    
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
    }

	return ret;
}

flag asn1SccBase_samples_Sonar_Decode(asn1SccBase_samples_Sonar* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode time */
	ret = asn1SccBase_Time_Decode(&pVal->time, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode timestamps */
	    ret = asn1SccBase_samples_Sonar_timestamps_Decode(&pVal->timestamps, pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode bin_duration */
	        ret = asn1SccBase_Time_Decode(&pVal->bin_duration, pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode beam_width */
	            ret = asn1SccBase_Angle_Decode(&pVal->beam_width, pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode beam_height */
	                ret = asn1SccBase_Angle_Decode(&pVal->beam_height, pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode bearings */
	                    ret = asn1SccBase_samples_Sonar_bearings_Decode(&pVal->bearings, pBitStrm, pErrCode);
	                    if (ret) {
	                        /*Decode speed_of_sound */
	                        ret = asn1SccT_Float_Decode(&pVal->speed_of_sound, pBitStrm, pErrCode);
	                        if (ret) {
	                            /*Decode bin_count */
	                            ret = asn1SccT_UInt32_Decode(&pVal->bin_count, pBitStrm, pErrCode);
	                            if (ret) {
	                                /*Decode beam_count */
	                                ret = asn1SccT_UInt32_Decode(&pVal->beam_count, pBitStrm, pErrCode);
	                                if (ret) {
	                                    /*Decode bins */
	                                    ret = asn1SccBase_samples_Sonar_bins_Decode(&pVal->bins, pBitStrm, pErrCode);
	                                
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	}


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_DepthMap_timestamps_Initialize(asn1SccBase_samples_DepthMap_timestamps* pVal)
{
    *pVal = (asn1SccBase_samples_DepthMap_timestamps) {    .nCount = 1,    .arr = 
    {
        {
            .microseconds = -9223372036854775807LL
        }        
    }
};
}
#endif

 
flag asn1SccBase_samples_DepthMap_timestamps_IsConstraintValid(const asn1SccBase_samples_DepthMap_timestamps* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_samples_DepthMap_timestamps);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_samples_DepthMap_timestamps;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccBase_Time_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}

flag asn1SccBase_samples_DepthMap_timestamps_Encode(const asn1SccBase_samples_DepthMap_timestamps* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? asn1SccBase_samples_DepthMap_timestamps_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccBase_Time_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag asn1SccBase_samples_DepthMap_timestamps_Decode(asn1SccBase_samples_DepthMap_timestamps* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : 268435496;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = asn1SccBase_Time_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_JointsTrajectory_times_val_Initialize(asn1SccBase_JointsTrajectory_times_val* pVal)
{
    *pVal = (asn1SccBase_JointsTrajectory_times_val) {    .nCount = 1,    .arr = 
    {
        {
            .microseconds = -9223372036854775807LL
        }        
    }
};
}
#endif

 
flag asn1SccBase_JointsTrajectory_times_val_IsConstraintValid(const asn1SccBase_JointsTrajectory_times_val* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_JointsTrajectory_times_val);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_JointsTrajectory_times_val;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccBase_Time_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}

flag asn1SccBase_JointsTrajectory_times_val_Encode(const asn1SccBase_JointsTrajectory_times_val* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? asn1SccBase_JointsTrajectory_times_val_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccBase_Time_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag asn1SccBase_JointsTrajectory_times_val_Decode(asn1SccBase_JointsTrajectory_times_val* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : 268435497;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = asn1SccBase_Time_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_frame_frame_size_t_Initialize(asn1SccBase_samples_frame_frame_size_t* pVal)
{
    *pVal = (asn1SccBase_samples_frame_frame_size_t) {
    .width = 0,
    .height = 0
};
}
#endif

 
flag asn1SccBase_samples_frame_frame_size_t_IsConstraintValid(const asn1SccBase_samples_frame_frame_size_t* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccT_UInt16_IsConstraintValid(&pVal->width, pErrCode);
	if (ret) {
	    ret = asn1SccT_UInt16_IsConstraintValid(&pVal->height, pErrCode);
	
	}

	return ret;
}

flag asn1SccBase_samples_frame_frame_size_t_Encode(const asn1SccBase_samples_frame_frame_size_t* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccBase_samples_frame_frame_size_t_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode width */
	    ret = asn1SccT_UInt16_Encode(&pVal->width, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode height */
	        ret = asn1SccT_UInt16_Encode(&pVal->height, pBitStrm, pErrCode, FALSE);
	    
	    }
    }

	return ret;
}

flag asn1SccBase_samples_frame_frame_size_t_Decode(asn1SccBase_samples_frame_frame_size_t* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode width */
	ret = asn1SccT_UInt16_Decode(&pVal->width, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode height */
	    ret = asn1SccT_UInt16_Decode(&pVal->height, pBitStrm, pErrCode);
	
	}


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_DistanceImage_Initialize(asn1SccBase_samples_DistanceImage* pVal)
{
    *pVal = (asn1SccBase_samples_DistanceImage) {
    .time = {
        .microseconds = -9223372036854775807LL
    },
    .width = 0,
    .height = 0,
    .scale_x = 0.00000000000000000000E+000,
    .scale_y = 0.00000000000000000000E+000,
    .center_x = 0.00000000000000000000E+000,
    .center_y = 0.00000000000000000000E+000,
    .data = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    }
};
}
#endif

 
flag asn1SccBase_samples_DistanceImage_IsConstraintValid(const asn1SccBase_samples_DistanceImage* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccBase_Time_IsConstraintValid(&pVal->time, pErrCode);
	if (ret) {
	    ret = asn1SccT_UInt16_IsConstraintValid(&pVal->width, pErrCode);
	    if (ret) {
	        ret = asn1SccT_UInt16_IsConstraintValid(&pVal->height, pErrCode);
	        if (ret) {
	            ret = asn1SccT_Float_IsConstraintValid(&pVal->scale_x, pErrCode);
	            if (ret) {
	                ret = asn1SccT_Float_IsConstraintValid(&pVal->scale_y, pErrCode);
	                if (ret) {
	                    ret = asn1SccT_Float_IsConstraintValid(&pVal->center_x, pErrCode);
	                    if (ret) {
	                        ret = asn1SccT_Float_IsConstraintValid(&pVal->center_y, pErrCode);
	                        if (ret) {
	                            ret = asn1SccBase_samples_DistanceImage_data_IsConstraintValid(&pVal->data, pErrCode);
	                        
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

	return ret;
}

flag asn1SccBase_samples_DistanceImage_Encode(const asn1SccBase_samples_DistanceImage* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccBase_samples_DistanceImage_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode time */
	    ret = asn1SccBase_Time_Encode(&pVal->time, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode width */
	        ret = asn1SccT_UInt16_Encode(&pVal->width, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode height */
	            ret = asn1SccT_UInt16_Encode(&pVal->height, pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode scale_x */
	                ret = asn1SccT_Float_Encode(&pVal->scale_x, pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode scale_y */
	                    ret = asn1SccT_Float_Encode(&pVal->scale_y, pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode center_x */
	                        ret = asn1SccT_Float_Encode(&pVal->center_x, pBitStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode center_y */
	                            ret = asn1SccT_Float_Encode(&pVal->center_y, pBitStrm, pErrCode, FALSE);
	                            if (ret) {
	                                /*Encode data */
	                                ret = asn1SccBase_samples_DistanceImage_data_Encode(&pVal->data, pBitStrm, pErrCode, FALSE);
	                            
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
    }

	return ret;
}

flag asn1SccBase_samples_DistanceImage_Decode(asn1SccBase_samples_DistanceImage* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode time */
	ret = asn1SccBase_Time_Decode(&pVal->time, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode width */
	    ret = asn1SccT_UInt16_Decode(&pVal->width, pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode height */
	        ret = asn1SccT_UInt16_Decode(&pVal->height, pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode scale_x */
	            ret = asn1SccT_Float_Decode(&pVal->scale_x, pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode scale_y */
	                ret = asn1SccT_Float_Decode(&pVal->scale_y, pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode center_x */
	                    ret = asn1SccT_Float_Decode(&pVal->center_x, pBitStrm, pErrCode);
	                    if (ret) {
	                        /*Decode center_y */
	                        ret = asn1SccT_Float_Decode(&pVal->center_y, pBitStrm, pErrCode);
	                        if (ret) {
	                            /*Decode data */
	                            ret = asn1SccBase_samples_DistanceImage_data_Decode(&pVal->data, pBitStrm, pErrCode);
	                        
	                        }
	                    }
	                }
	            }
	        }
	    }
	}


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_JointTransform_Initialize(asn1SccBase_JointTransform* pVal)
{
    *pVal = (asn1SccBase_JointTransform) {
    .sourceframe = {0,
        {
        }
    },
    .targetframe = {0,
        {
        }
    },
    .rotationaxis = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    }
};
}
#endif

 
flag asn1SccBase_JointTransform_IsConstraintValid(const asn1SccBase_JointTransform* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccT_String_IsConstraintValid(&pVal->sourceframe, pErrCode);
	if (ret) {
	    ret = asn1SccT_String_IsConstraintValid(&pVal->targetframe, pErrCode);
	    if (ret) {
	        ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->rotationaxis, pErrCode);
	    
	    }
	}

	return ret;
}

flag asn1SccBase_JointTransform_Encode(const asn1SccBase_JointTransform* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccBase_JointTransform_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode sourceframe */
	    ret = asn1SccT_String_Encode(&pVal->sourceframe, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode targetframe */
	        ret = asn1SccT_String_Encode(&pVal->targetframe, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode rotationaxis */
	            ret = asn1SccWrappers_Vector3d_Encode(&pVal->rotationaxis, pBitStrm, pErrCode, FALSE);
	        
	        }
	    }
    }

	return ret;
}

flag asn1SccBase_JointTransform_Decode(asn1SccBase_JointTransform* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode sourceframe */
	ret = asn1SccT_String_Decode(&pVal->sourceframe, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode targetframe */
	    ret = asn1SccT_String_Decode(&pVal->targetframe, pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode rotationaxis */
	        ret = asn1SccWrappers_Vector3d_Decode(&pVal->rotationaxis, pBitStrm, pErrCode);
	    
	    }
	}


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_NamedVector_Base_JointTransform_elements_Initialize(asn1SccBase_NamedVector_Base_JointTransform_elements* pVal)
{
    *pVal = (asn1SccBase_NamedVector_Base_JointTransform_elements) {    .nCount = 1,    .arr = 
    {
        {
            .sourceframe = {0,
                {
                }
            },
            .targetframe = {0,
                {
                }
            },
            .rotationaxis = {
                .data = {    .nCount = 1,    .arr = 
                    {
                        0.00000000000000000000E+000        
                    }
                }
            }
        }        
    }
};
}
#endif

 
flag asn1SccBase_NamedVector_Base_JointTransform_elements_IsConstraintValid(const asn1SccBase_NamedVector_Base_JointTransform_elements* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_NamedVector_Base_JointTransform_elements);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_NamedVector_Base_JointTransform_elements;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccBase_JointTransform_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}

flag asn1SccBase_NamedVector_Base_JointTransform_elements_Encode(const asn1SccBase_NamedVector_Base_JointTransform_elements* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? asn1SccBase_NamedVector_Base_JointTransform_elements_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccBase_JointTransform_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag asn1SccBase_NamedVector_Base_JointTransform_elements_Decode(asn1SccBase_NamedVector_Base_JointTransform_elements* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : 268435498;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = asn1SccBase_JointTransform_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_JointTransformVector_elements_Initialize(asn1SccBase_JointTransformVector_elements* pVal)
{
    *pVal = (asn1SccBase_JointTransformVector_elements) {    .nCount = 1,    .arr = 
    {
        {
            .sourceframe = {0,
                {
                }
            },
            .targetframe = {0,
                {
                }
            },
            .rotationaxis = {
                .data = {    .nCount = 1,    .arr = 
                    {
                        0.00000000000000000000E+000        
                    }
                }
            }
        }        
    }
};
}
#endif

 
flag asn1SccBase_JointTransformVector_elements_IsConstraintValid(const asn1SccBase_JointTransformVector_elements* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_JointTransformVector_elements);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_JointTransformVector_elements;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccBase_JointTransform_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}

flag asn1SccBase_JointTransformVector_elements_Encode(const asn1SccBase_JointTransformVector_elements* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? asn1SccBase_JointTransformVector_elements_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccBase_JointTransform_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag asn1SccBase_JointTransformVector_elements_Decode(asn1SccBase_JointTransformVector_elements* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : 268435499;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = asn1SccBase_JointTransform_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_RigidBodyState_Initialize(asn1SccBase_samples_RigidBodyState* pVal)
{
    *pVal = (asn1SccBase_samples_RigidBodyState) {
    .time = {
        .microseconds = -9223372036854775807LL
    },
    .sourceframe = {0,
        {
        }
    },
    .targetframe = {0,
        {
        }
    },
    .position = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .cov_position = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .orientation = {
        .im = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        },
        .re = 0.00000000000000000000E+000
    },
    .cov_orientation = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .velocity = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .cov_velocity = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .angular_velocity = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .cov_angular_velocity = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    }
};
}
#endif

 
flag asn1SccBase_samples_RigidBodyState_IsConstraintValid(const asn1SccBase_samples_RigidBodyState* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccBase_Time_IsConstraintValid(&pVal->time, pErrCode);
	if (ret) {
	    ret = asn1SccT_String_IsConstraintValid(&pVal->sourceframe, pErrCode);
	    if (ret) {
	        ret = asn1SccT_String_IsConstraintValid(&pVal->targetframe, pErrCode);
	        if (ret) {
	            ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->position, pErrCode);
	            if (ret) {
	                ret = asn1SccWrappers_Matrix3d_IsConstraintValid(&pVal->cov_position, pErrCode);
	                if (ret) {
	                    ret = asn1SccWrappers_Quaterniond_IsConstraintValid(&pVal->orientation, pErrCode);
	                    if (ret) {
	                        ret = asn1SccWrappers_Matrix3d_IsConstraintValid(&pVal->cov_orientation, pErrCode);
	                        if (ret) {
	                            ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->velocity, pErrCode);
	                            if (ret) {
	                                ret = asn1SccWrappers_Matrix3d_IsConstraintValid(&pVal->cov_velocity, pErrCode);
	                                if (ret) {
	                                    ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->angular_velocity, pErrCode);
	                                    if (ret) {
	                                        ret = asn1SccWrappers_Matrix3d_IsConstraintValid(&pVal->cov_angular_velocity, pErrCode);
	                                    
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

	return ret;
}

flag asn1SccBase_samples_RigidBodyState_Encode(const asn1SccBase_samples_RigidBodyState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccBase_samples_RigidBodyState_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode time */
	    ret = asn1SccBase_Time_Encode(&pVal->time, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode sourceframe */
	        ret = asn1SccT_String_Encode(&pVal->sourceframe, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode targetframe */
	            ret = asn1SccT_String_Encode(&pVal->targetframe, pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode position */
	                ret = asn1SccWrappers_Vector3d_Encode(&pVal->position, pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode cov_position */
	                    ret = asn1SccWrappers_Matrix3d_Encode(&pVal->cov_position, pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode orientation */
	                        ret = asn1SccWrappers_Quaterniond_Encode(&pVal->orientation, pBitStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode cov_orientation */
	                            ret = asn1SccWrappers_Matrix3d_Encode(&pVal->cov_orientation, pBitStrm, pErrCode, FALSE);
	                            if (ret) {
	                                /*Encode velocity */
	                                ret = asn1SccWrappers_Vector3d_Encode(&pVal->velocity, pBitStrm, pErrCode, FALSE);
	                                if (ret) {
	                                    /*Encode cov_velocity */
	                                    ret = asn1SccWrappers_Matrix3d_Encode(&pVal->cov_velocity, pBitStrm, pErrCode, FALSE);
	                                    if (ret) {
	                                        /*Encode angular_velocity */
	                                        ret = asn1SccWrappers_Vector3d_Encode(&pVal->angular_velocity, pBitStrm, pErrCode, FALSE);
	                                        if (ret) {
	                                            /*Encode cov_angular_velocity */
	                                            ret = asn1SccWrappers_Matrix3d_Encode(&pVal->cov_angular_velocity, pBitStrm, pErrCode, FALSE);
	                                        
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
    }

	return ret;
}

flag asn1SccBase_samples_RigidBodyState_Decode(asn1SccBase_samples_RigidBodyState* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode time */
	ret = asn1SccBase_Time_Decode(&pVal->time, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode sourceframe */
	    ret = asn1SccT_String_Decode(&pVal->sourceframe, pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode targetframe */
	        ret = asn1SccT_String_Decode(&pVal->targetframe, pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode position */
	            ret = asn1SccWrappers_Vector3d_Decode(&pVal->position, pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode cov_position */
	                ret = asn1SccWrappers_Matrix3d_Decode(&pVal->cov_position, pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode orientation */
	                    ret = asn1SccWrappers_Quaterniond_Decode(&pVal->orientation, pBitStrm, pErrCode);
	                    if (ret) {
	                        /*Decode cov_orientation */
	                        ret = asn1SccWrappers_Matrix3d_Decode(&pVal->cov_orientation, pBitStrm, pErrCode);
	                        if (ret) {
	                            /*Decode velocity */
	                            ret = asn1SccWrappers_Vector3d_Decode(&pVal->velocity, pBitStrm, pErrCode);
	                            if (ret) {
	                                /*Decode cov_velocity */
	                                ret = asn1SccWrappers_Matrix3d_Decode(&pVal->cov_velocity, pBitStrm, pErrCode);
	                                if (ret) {
	                                    /*Decode angular_velocity */
	                                    ret = asn1SccWrappers_Vector3d_Decode(&pVal->angular_velocity, pBitStrm, pErrCode);
	                                    if (ret) {
	                                        /*Decode cov_angular_velocity */
	                                        ret = asn1SccWrappers_Matrix3d_Decode(&pVal->cov_angular_velocity, pBitStrm, pErrCode);
	                                    
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	}


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_frame_frame_attrib_t_Initialize(asn1SccBase_samples_frame_frame_attrib_t* pVal)
{
    *pVal = (asn1SccBase_samples_frame_frame_attrib_t) {
    .data = {0,
        {
        }
    },
    .name_val = {0,
        {
        }
    }
};
}
#endif

 
flag asn1SccBase_samples_frame_frame_attrib_t_IsConstraintValid(const asn1SccBase_samples_frame_frame_attrib_t* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccT_String_IsConstraintValid(&pVal->data, pErrCode);
	if (ret) {
	    ret = asn1SccT_String_IsConstraintValid(&pVal->name_val, pErrCode);
	
	}

	return ret;
}

flag asn1SccBase_samples_frame_frame_attrib_t_Encode(const asn1SccBase_samples_frame_frame_attrib_t* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccBase_samples_frame_frame_attrib_t_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode data */
	    ret = asn1SccT_String_Encode(&pVal->data, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode name_val */
	        ret = asn1SccT_String_Encode(&pVal->name_val, pBitStrm, pErrCode, FALSE);
	    
	    }
    }

	return ret;
}

flag asn1SccBase_samples_frame_frame_attrib_t_Decode(asn1SccBase_samples_frame_frame_attrib_t* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode data */
	ret = asn1SccT_String_Decode(&pVal->data, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode name_val */
	    ret = asn1SccT_String_Decode(&pVal->name_val, pBitStrm, pErrCode);
	
	}


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_frame_Frame_attributes_Initialize(asn1SccBase_samples_frame_Frame_attributes* pVal)
{
    *pVal = (asn1SccBase_samples_frame_Frame_attributes) {    .nCount = 1,    .arr = 
    {
        {
            .data = {0,
                {
                }
            },
            .name_val = {0,
                {
                }
            }
        }        
    }
};
}
#endif

 
flag asn1SccBase_samples_frame_Frame_attributes_IsConstraintValid(const asn1SccBase_samples_frame_Frame_attributes* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_samples_frame_Frame_attributes);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_samples_frame_Frame_attributes;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccBase_samples_frame_frame_attrib_t_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}

flag asn1SccBase_samples_frame_Frame_attributes_Encode(const asn1SccBase_samples_frame_Frame_attributes* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? asn1SccBase_samples_frame_Frame_attributes_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccBase_samples_frame_frame_attrib_t_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag asn1SccBase_samples_frame_Frame_attributes_Decode(asn1SccBase_samples_frame_Frame_attributes* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : 268435500;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = asn1SccBase_samples_frame_frame_attrib_t_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_JointTransform_m_Initialize(asn1SccBase_JointTransform_m* pVal)
{
    *pVal = (asn1SccBase_JointTransform_m) {
    .sourceframe = {0,
        {
        }
    },
    .targetframe = {0,
        {
        }
    },
    .rotationaxis = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    }
};
}
#endif

 
flag asn1SccBase_JointTransform_m_IsConstraintValid(const asn1SccBase_JointTransform_m* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccT_String_IsConstraintValid(&pVal->sourceframe, pErrCode);
	if (ret) {
	    ret = asn1SccT_String_IsConstraintValid(&pVal->targetframe, pErrCode);
	    if (ret) {
	        ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->rotationaxis, pErrCode);
	    
	    }
	}

	return ret;
}

flag asn1SccBase_JointTransform_m_Encode(const asn1SccBase_JointTransform_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccBase_JointTransform_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode sourceframe */
	    ret = asn1SccT_String_Encode(&pVal->sourceframe, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode targetframe */
	        ret = asn1SccT_String_Encode(&pVal->targetframe, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode rotationaxis */
	            ret = asn1SccWrappers_Vector3d_Encode(&pVal->rotationaxis, pBitStrm, pErrCode, FALSE);
	        
	        }
	    }
    }

	return ret;
}

flag asn1SccBase_JointTransform_m_Decode(asn1SccBase_JointTransform_m* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode sourceframe */
	ret = asn1SccT_String_Decode(&pVal->sourceframe, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode targetframe */
	    ret = asn1SccT_String_Decode(&pVal->targetframe, pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode rotationaxis */
	        ret = asn1SccWrappers_Vector3d_Decode(&pVal->rotationaxis, pBitStrm, pErrCode);
	    
	    }
	}


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccStd_orogen_typekits_mtype_std_vector_base_JointTransform_Initialize(asn1SccStd_orogen_typekits_mtype_std_vector_base_JointTransform* pVal)
{
    *pVal = (asn1SccStd_orogen_typekits_mtype_std_vector_base_JointTransform) {    .nCount = 1,    .arr = 
    {
        {
            .sourceframe = {0,
                {
                }
            },
            .targetframe = {0,
                {
                }
            },
            .rotationaxis = {
                .data = {    .nCount = 1,    .arr = 
                    {
                        0.00000000000000000000E+000        
                    }
                }
            }
        }        
    }
};
}
#endif

 
flag asn1SccStd_orogen_typekits_mtype_std_vector_base_JointTransform_IsConstraintValid(const asn1SccStd_orogen_typekits_mtype_std_vector_base_JointTransform* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numStd_orogen_typekits_mtype_std_vector_base_JointTransform);
	*pErrCode = ret ? 0 : ERR_asn1SccStd_orogen_typekits_mtype_std_vector_base_JointTransform;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccBase_JointTransform_m_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}

flag asn1SccStd_orogen_typekits_mtype_std_vector_base_JointTransform_Encode(const asn1SccStd_orogen_typekits_mtype_std_vector_base_JointTransform* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? asn1SccStd_orogen_typekits_mtype_std_vector_base_JointTransform_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccBase_JointTransform_m_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag asn1SccStd_orogen_typekits_mtype_std_vector_base_JointTransform_Decode(asn1SccStd_orogen_typekits_mtype_std_vector_base_JointTransform* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : 268435501;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = asn1SccBase_JointTransform_m_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_RigidBodyState_m_Initialize(asn1SccBase_samples_RigidBodyState_m* pVal)
{
    *pVal = (asn1SccBase_samples_RigidBodyState_m) {
    .time = {
        .microseconds = -9223372036854775807LL
    },
    .sourceframe = {0,
        {
        }
    },
    .targetframe = {0,
        {
        }
    },
    .position = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .cov_position = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .orientation = {
        .im = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        },
        .re = 0.00000000000000000000E+000
    },
    .cov_orientation = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .velocity = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .cov_velocity = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .angular_velocity = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    },
    .cov_angular_velocity = {
        .data = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    }
};
}
#endif

 
flag asn1SccBase_samples_RigidBodyState_m_IsConstraintValid(const asn1SccBase_samples_RigidBodyState_m* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccBase_Time_IsConstraintValid(&pVal->time, pErrCode);
	if (ret) {
	    ret = asn1SccT_String_IsConstraintValid(&pVal->sourceframe, pErrCode);
	    if (ret) {
	        ret = asn1SccT_String_IsConstraintValid(&pVal->targetframe, pErrCode);
	        if (ret) {
	            ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->position, pErrCode);
	            if (ret) {
	                ret = asn1SccWrappers_Matrix3d_IsConstraintValid(&pVal->cov_position, pErrCode);
	                if (ret) {
	                    ret = asn1SccWrappers_Quaterniond_IsConstraintValid(&pVal->orientation, pErrCode);
	                    if (ret) {
	                        ret = asn1SccWrappers_Matrix3d_IsConstraintValid(&pVal->cov_orientation, pErrCode);
	                        if (ret) {
	                            ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->velocity, pErrCode);
	                            if (ret) {
	                                ret = asn1SccWrappers_Matrix3d_IsConstraintValid(&pVal->cov_velocity, pErrCode);
	                                if (ret) {
	                                    ret = asn1SccWrappers_Vector3d_IsConstraintValid(&pVal->angular_velocity, pErrCode);
	                                    if (ret) {
	                                        ret = asn1SccWrappers_Matrix3d_IsConstraintValid(&pVal->cov_angular_velocity, pErrCode);
	                                    
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

	return ret;
}

flag asn1SccBase_samples_RigidBodyState_m_Encode(const asn1SccBase_samples_RigidBodyState_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccBase_samples_RigidBodyState_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode time */
	    ret = asn1SccBase_Time_Encode(&pVal->time, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode sourceframe */
	        ret = asn1SccT_String_Encode(&pVal->sourceframe, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode targetframe */
	            ret = asn1SccT_String_Encode(&pVal->targetframe, pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode position */
	                ret = asn1SccWrappers_Vector3d_Encode(&pVal->position, pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode cov_position */
	                    ret = asn1SccWrappers_Matrix3d_Encode(&pVal->cov_position, pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode orientation */
	                        ret = asn1SccWrappers_Quaterniond_Encode(&pVal->orientation, pBitStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode cov_orientation */
	                            ret = asn1SccWrappers_Matrix3d_Encode(&pVal->cov_orientation, pBitStrm, pErrCode, FALSE);
	                            if (ret) {
	                                /*Encode velocity */
	                                ret = asn1SccWrappers_Vector3d_Encode(&pVal->velocity, pBitStrm, pErrCode, FALSE);
	                                if (ret) {
	                                    /*Encode cov_velocity */
	                                    ret = asn1SccWrappers_Matrix3d_Encode(&pVal->cov_velocity, pBitStrm, pErrCode, FALSE);
	                                    if (ret) {
	                                        /*Encode angular_velocity */
	                                        ret = asn1SccWrappers_Vector3d_Encode(&pVal->angular_velocity, pBitStrm, pErrCode, FALSE);
	                                        if (ret) {
	                                            /*Encode cov_angular_velocity */
	                                            ret = asn1SccWrappers_Matrix3d_Encode(&pVal->cov_angular_velocity, pBitStrm, pErrCode, FALSE);
	                                        
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
    }

	return ret;
}

flag asn1SccBase_samples_RigidBodyState_m_Decode(asn1SccBase_samples_RigidBodyState_m* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode time */
	ret = asn1SccBase_Time_Decode(&pVal->time, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode sourceframe */
	    ret = asn1SccT_String_Decode(&pVal->sourceframe, pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode targetframe */
	        ret = asn1SccT_String_Decode(&pVal->targetframe, pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode position */
	            ret = asn1SccWrappers_Vector3d_Decode(&pVal->position, pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode cov_position */
	                ret = asn1SccWrappers_Matrix3d_Decode(&pVal->cov_position, pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode orientation */
	                    ret = asn1SccWrappers_Quaterniond_Decode(&pVal->orientation, pBitStrm, pErrCode);
	                    if (ret) {
	                        /*Decode cov_orientation */
	                        ret = asn1SccWrappers_Matrix3d_Decode(&pVal->cov_orientation, pBitStrm, pErrCode);
	                        if (ret) {
	                            /*Decode velocity */
	                            ret = asn1SccWrappers_Vector3d_Decode(&pVal->velocity, pBitStrm, pErrCode);
	                            if (ret) {
	                                /*Decode cov_velocity */
	                                ret = asn1SccWrappers_Matrix3d_Decode(&pVal->cov_velocity, pBitStrm, pErrCode);
	                                if (ret) {
	                                    /*Decode angular_velocity */
	                                    ret = asn1SccWrappers_Vector3d_Decode(&pVal->angular_velocity, pBitStrm, pErrCode);
	                                    if (ret) {
	                                        /*Decode cov_angular_velocity */
	                                        ret = asn1SccWrappers_Matrix3d_Decode(&pVal->cov_angular_velocity, pBitStrm, pErrCode);
	                                    
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	}


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_Wrenches_m_names_Initialize(asn1SccBase_samples_Wrenches_m_names* pVal)
{
    *pVal = (asn1SccBase_samples_Wrenches_m_names) {    .nCount = 1,    .arr = 
    {
        {0,
            {
            }
        }        
    }
};
}
#endif

 
flag asn1SccBase_samples_Wrenches_m_names_IsConstraintValid(const asn1SccBase_samples_Wrenches_m_names* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_samples_Wrenches_m_names);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_samples_Wrenches_m_names;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_String_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}

flag asn1SccBase_samples_Wrenches_m_names_Encode(const asn1SccBase_samples_Wrenches_m_names* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? asn1SccBase_samples_Wrenches_m_names_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccT_String_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag asn1SccBase_samples_Wrenches_m_names_Decode(asn1SccBase_samples_Wrenches_m_names* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : 268435502;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = asn1SccT_String_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_Wrenches_m_Initialize(asn1SccBase_samples_Wrenches_m* pVal)
{
    *pVal = (asn1SccBase_samples_Wrenches_m) {
    .names = {    .nCount = 1,    .arr = 
        {
            {0,
                {
                }
            }        
        }
    },
    .elements = {    .nCount = 1,    .arr = 
        {
            {
                .force = {
                    .data = {    .nCount = 1,    .arr = 
                        {
                            0.00000000000000000000E+000        
                        }
                    }
                },
                .torque = {
                    .data = {    .nCount = 1,    .arr = 
                        {
                            0.00000000000000000000E+000        
                        }
                    }
                }
            }        
        }
    },
    .time = {
        .microseconds = -9223372036854775807LL
    }
};
}
#endif

 
flag asn1SccBase_samples_Wrenches_m_IsConstraintValid(const asn1SccBase_samples_Wrenches_m* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccBase_samples_Wrenches_m_names_IsConstraintValid(&pVal->names, pErrCode);
	if (ret) {
	    ret = asn1SccStd_orogen_typekits_mtype_std_vector_base_Wrench_IsConstraintValid(&pVal->elements, pErrCode);
	    if (ret) {
	        ret = asn1SccBase_Time_IsConstraintValid(&pVal->time, pErrCode);
	    
	    }
	}

	return ret;
}

flag asn1SccBase_samples_Wrenches_m_Encode(const asn1SccBase_samples_Wrenches_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccBase_samples_Wrenches_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode names */
	    ret = asn1SccBase_samples_Wrenches_m_names_Encode(&pVal->names, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode elements */
	        ret = asn1SccStd_orogen_typekits_mtype_std_vector_base_Wrench_Encode(&pVal->elements, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode time */
	            ret = asn1SccBase_Time_Encode(&pVal->time, pBitStrm, pErrCode, FALSE);
	        
	        }
	    }
    }

	return ret;
}

flag asn1SccBase_samples_Wrenches_m_Decode(asn1SccBase_samples_Wrenches_m* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode names */
	ret = asn1SccBase_samples_Wrenches_m_names_Decode(&pVal->names, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode elements */
	    ret = asn1SccStd_orogen_typekits_mtype_std_vector_base_Wrench_Decode(&pVal->elements, pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode time */
	        ret = asn1SccBase_Time_Decode(&pVal->time, pBitStrm, pErrCode);
	    
	    }
	}


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_NamedVector_base_Wrench_m_names_Initialize(asn1SccBase_NamedVector_base_Wrench_m_names* pVal)
{
    *pVal = (asn1SccBase_NamedVector_base_Wrench_m_names) {    .nCount = 1,    .arr = 
    {
        {0,
            {
            }
        }        
    }
};
}
#endif

 
flag asn1SccBase_NamedVector_base_Wrench_m_names_IsConstraintValid(const asn1SccBase_NamedVector_base_Wrench_m_names* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_NamedVector_base_Wrench_m_names);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_NamedVector_base_Wrench_m_names;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_String_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}

flag asn1SccBase_NamedVector_base_Wrench_m_names_Encode(const asn1SccBase_NamedVector_base_Wrench_m_names* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? asn1SccBase_NamedVector_base_Wrench_m_names_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccT_String_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag asn1SccBase_NamedVector_base_Wrench_m_names_Decode(asn1SccBase_NamedVector_base_Wrench_m_names* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : 268435503;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = asn1SccT_String_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_NamedVector_base_Wrench_m_Initialize(asn1SccBase_NamedVector_base_Wrench_m* pVal)
{
    *pVal = (asn1SccBase_NamedVector_base_Wrench_m) {
    .names = {    .nCount = 1,    .arr = 
        {
            {0,
                {
                }
            }        
        }
    },
    .elements = {    .nCount = 1,    .arr = 
        {
            {
                .force = {
                    .data = {    .nCount = 1,    .arr = 
                        {
                            0.00000000000000000000E+000        
                        }
                    }
                },
                .torque = {
                    .data = {    .nCount = 1,    .arr = 
                        {
                            0.00000000000000000000E+000        
                        }
                    }
                }
            }        
        }
    }
};
}
#endif

 
flag asn1SccBase_NamedVector_base_Wrench_m_IsConstraintValid(const asn1SccBase_NamedVector_base_Wrench_m* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccBase_NamedVector_base_Wrench_m_names_IsConstraintValid(&pVal->names, pErrCode);
	if (ret) {
	    ret = asn1SccStd_orogen_typekits_mtype_std_vector_base_Wrench_IsConstraintValid(&pVal->elements, pErrCode);
	
	}

	return ret;
}

flag asn1SccBase_NamedVector_base_Wrench_m_Encode(const asn1SccBase_NamedVector_base_Wrench_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccBase_NamedVector_base_Wrench_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode names */
	    ret = asn1SccBase_NamedVector_base_Wrench_m_names_Encode(&pVal->names, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode elements */
	        ret = asn1SccStd_orogen_typekits_mtype_std_vector_base_Wrench_Encode(&pVal->elements, pBitStrm, pErrCode, FALSE);
	    
	    }
    }

	return ret;
}

flag asn1SccBase_NamedVector_base_Wrench_m_Decode(asn1SccBase_NamedVector_base_Wrench_m* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode names */
	ret = asn1SccBase_NamedVector_base_Wrench_m_names_Decode(&pVal->names, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode elements */
	    ret = asn1SccStd_orogen_typekits_mtype_std_vector_base_Wrench_Decode(&pVal->elements, pBitStrm, pErrCode);
	
	}


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_NamedVector_base_JointTransform_m_names_Initialize(asn1SccBase_NamedVector_base_JointTransform_m_names* pVal)
{
    *pVal = (asn1SccBase_NamedVector_base_JointTransform_m_names) {    .nCount = 1,    .arr = 
    {
        {0,
            {
            }
        }        
    }
};
}
#endif

 
flag asn1SccBase_NamedVector_base_JointTransform_m_names_IsConstraintValid(const asn1SccBase_NamedVector_base_JointTransform_m_names* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_NamedVector_base_JointTransform_m_names);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_NamedVector_base_JointTransform_m_names;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_String_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}

flag asn1SccBase_NamedVector_base_JointTransform_m_names_Encode(const asn1SccBase_NamedVector_base_JointTransform_m_names* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? asn1SccBase_NamedVector_base_JointTransform_m_names_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccT_String_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag asn1SccBase_NamedVector_base_JointTransform_m_names_Decode(asn1SccBase_NamedVector_base_JointTransform_m_names* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : 268435504;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = asn1SccT_String_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_NamedVector_base_JointTransform_m_Initialize(asn1SccBase_NamedVector_base_JointTransform_m* pVal)
{
    *pVal = (asn1SccBase_NamedVector_base_JointTransform_m) {
    .names = {    .nCount = 1,    .arr = 
        {
            {0,
                {
                }
            }        
        }
    },
    .elements = {    .nCount = 1,    .arr = 
        {
            {
                .sourceframe = {0,
                    {
                    }
                },
                .targetframe = {0,
                    {
                    }
                },
                .rotationaxis = {
                    .data = {    .nCount = 1,    .arr = 
                        {
                            0.00000000000000000000E+000        
                        }
                    }
                }
            }        
        }
    }
};
}
#endif

 
flag asn1SccBase_NamedVector_base_JointTransform_m_IsConstraintValid(const asn1SccBase_NamedVector_base_JointTransform_m* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccBase_NamedVector_base_JointTransform_m_names_IsConstraintValid(&pVal->names, pErrCode);
	if (ret) {
	    ret = asn1SccStd_orogen_typekits_mtype_std_vector_base_JointTransform_IsConstraintValid(&pVal->elements, pErrCode);
	
	}

	return ret;
}

flag asn1SccBase_NamedVector_base_JointTransform_m_Encode(const asn1SccBase_NamedVector_base_JointTransform_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccBase_NamedVector_base_JointTransform_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode names */
	    ret = asn1SccBase_NamedVector_base_JointTransform_m_names_Encode(&pVal->names, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode elements */
	        ret = asn1SccStd_orogen_typekits_mtype_std_vector_base_JointTransform_Encode(&pVal->elements, pBitStrm, pErrCode, FALSE);
	    
	    }
    }

	return ret;
}

flag asn1SccBase_NamedVector_base_JointTransform_m_Decode(asn1SccBase_NamedVector_base_JointTransform_m* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode names */
	ret = asn1SccBase_NamedVector_base_JointTransform_m_names_Decode(&pVal->names, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode elements */
	    ret = asn1SccStd_orogen_typekits_mtype_std_vector_base_JointTransform_Decode(&pVal->elements, pBitStrm, pErrCode);
	
	}


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_JointTransformVector_m_names_Initialize(asn1SccBase_JointTransformVector_m_names* pVal)
{
    *pVal = (asn1SccBase_JointTransformVector_m_names) {    .nCount = 1,    .arr = 
    {
        {0,
            {
            }
        }        
    }
};
}
#endif

 
flag asn1SccBase_JointTransformVector_m_names_IsConstraintValid(const asn1SccBase_JointTransformVector_m_names* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_JointTransformVector_m_names);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_JointTransformVector_m_names;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_String_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}

flag asn1SccBase_JointTransformVector_m_names_Encode(const asn1SccBase_JointTransformVector_m_names* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? asn1SccBase_JointTransformVector_m_names_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccT_String_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag asn1SccBase_JointTransformVector_m_names_Decode(asn1SccBase_JointTransformVector_m_names* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : 268435505;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = asn1SccT_String_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_JointTransformVector_m_Initialize(asn1SccBase_JointTransformVector_m* pVal)
{
    *pVal = (asn1SccBase_JointTransformVector_m) {
    .names = {    .nCount = 1,    .arr = 
        {
            {0,
                {
                }
            }        
        }
    },
    .elements = {    .nCount = 1,    .arr = 
        {
            {
                .sourceframe = {0,
                    {
                    }
                },
                .targetframe = {0,
                    {
                    }
                },
                .rotationaxis = {
                    .data = {    .nCount = 1,    .arr = 
                        {
                            0.00000000000000000000E+000        
                        }
                    }
                }
            }        
        }
    }
};
}
#endif

 
flag asn1SccBase_JointTransformVector_m_IsConstraintValid(const asn1SccBase_JointTransformVector_m* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccBase_JointTransformVector_m_names_IsConstraintValid(&pVal->names, pErrCode);
	if (ret) {
	    ret = asn1SccStd_orogen_typekits_mtype_std_vector_base_JointTransform_IsConstraintValid(&pVal->elements, pErrCode);
	
	}

	return ret;
}

flag asn1SccBase_JointTransformVector_m_Encode(const asn1SccBase_JointTransformVector_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccBase_JointTransformVector_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode names */
	    ret = asn1SccBase_JointTransformVector_m_names_Encode(&pVal->names, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode elements */
	        ret = asn1SccStd_orogen_typekits_mtype_std_vector_base_JointTransform_Encode(&pVal->elements, pBitStrm, pErrCode, FALSE);
	    
	    }
    }

	return ret;
}

flag asn1SccBase_JointTransformVector_m_Decode(asn1SccBase_JointTransformVector_m* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode names */
	ret = asn1SccBase_JointTransformVector_m_names_Decode(&pVal->names, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode elements */
	    ret = asn1SccStd_orogen_typekits_mtype_std_vector_base_JointTransform_Decode(&pVal->elements, pBitStrm, pErrCode);
	
	}


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_NamedVector_Base_JointTransform_names_Initialize(asn1SccBase_NamedVector_Base_JointTransform_names* pVal)
{
    *pVal = (asn1SccBase_NamedVector_Base_JointTransform_names) {    .nCount = 1,    .arr = 
    {
        {0,
            {
            }
        }        
    }
};
}
#endif

 
flag asn1SccBase_NamedVector_Base_JointTransform_names_IsConstraintValid(const asn1SccBase_NamedVector_Base_JointTransform_names* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_NamedVector_Base_JointTransform_names);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_NamedVector_Base_JointTransform_names;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_String_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}

flag asn1SccBase_NamedVector_Base_JointTransform_names_Encode(const asn1SccBase_NamedVector_Base_JointTransform_names* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? asn1SccBase_NamedVector_Base_JointTransform_names_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccT_String_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag asn1SccBase_NamedVector_Base_JointTransform_names_Decode(asn1SccBase_NamedVector_Base_JointTransform_names* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : 268435506;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = asn1SccT_String_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_NamedVector_Base_JointTransform_Initialize(asn1SccBase_NamedVector_Base_JointTransform* pVal)
{
    *pVal = (asn1SccBase_NamedVector_Base_JointTransform) {
    .names = {    .nCount = 1,    .arr = 
        {
            {0,
                {
                }
            }        
        }
    },
    .elements = {    .nCount = 1,    .arr = 
        {
            {
                .sourceframe = {0,
                    {
                    }
                },
                .targetframe = {0,
                    {
                    }
                },
                .rotationaxis = {
                    .data = {    .nCount = 1,    .arr = 
                        {
                            0.00000000000000000000E+000        
                        }
                    }
                }
            }        
        }
    }
};
}
#endif

 
flag asn1SccBase_NamedVector_Base_JointTransform_IsConstraintValid(const asn1SccBase_NamedVector_Base_JointTransform* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccBase_NamedVector_Base_JointTransform_names_IsConstraintValid(&pVal->names, pErrCode);
	if (ret) {
	    ret = asn1SccBase_NamedVector_Base_JointTransform_elements_IsConstraintValid(&pVal->elements, pErrCode);
	
	}

	return ret;
}

flag asn1SccBase_NamedVector_Base_JointTransform_Encode(const asn1SccBase_NamedVector_Base_JointTransform* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccBase_NamedVector_Base_JointTransform_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode names */
	    ret = asn1SccBase_NamedVector_Base_JointTransform_names_Encode(&pVal->names, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode elements */
	        ret = asn1SccBase_NamedVector_Base_JointTransform_elements_Encode(&pVal->elements, pBitStrm, pErrCode, FALSE);
	    
	    }
    }

	return ret;
}

flag asn1SccBase_NamedVector_Base_JointTransform_Decode(asn1SccBase_NamedVector_Base_JointTransform* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode names */
	ret = asn1SccBase_NamedVector_Base_JointTransform_names_Decode(&pVal->names, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode elements */
	    ret = asn1SccBase_NamedVector_Base_JointTransform_elements_Decode(&pVal->elements, pBitStrm, pErrCode);
	
	}


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_JointTransformVector_names_Initialize(asn1SccBase_JointTransformVector_names* pVal)
{
    *pVal = (asn1SccBase_JointTransformVector_names) {    .nCount = 1,    .arr = 
    {
        {0,
            {
            }
        }        
    }
};
}
#endif

 
flag asn1SccBase_JointTransformVector_names_IsConstraintValid(const asn1SccBase_JointTransformVector_names* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_JointTransformVector_names);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_JointTransformVector_names;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_String_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}

flag asn1SccBase_JointTransformVector_names_Encode(const asn1SccBase_JointTransformVector_names* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? asn1SccBase_JointTransformVector_names_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccT_String_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag asn1SccBase_JointTransformVector_names_Decode(asn1SccBase_JointTransformVector_names* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : 268435507;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = asn1SccT_String_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_JointTransformVector_Initialize(asn1SccBase_JointTransformVector* pVal)
{
    *pVal = (asn1SccBase_JointTransformVector) {
    .names = {    .nCount = 1,    .arr = 
        {
            {0,
                {
                }
            }        
        }
    },
    .elements = {    .nCount = 1,    .arr = 
        {
            {
                .sourceframe = {0,
                    {
                    }
                },
                .targetframe = {0,
                    {
                    }
                },
                .rotationaxis = {
                    .data = {    .nCount = 1,    .arr = 
                        {
                            0.00000000000000000000E+000        
                        }
                    }
                }
            }        
        }
    }
};
}
#endif

 
flag asn1SccBase_JointTransformVector_IsConstraintValid(const asn1SccBase_JointTransformVector* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccBase_JointTransformVector_names_IsConstraintValid(&pVal->names, pErrCode);
	if (ret) {
	    ret = asn1SccBase_JointTransformVector_elements_IsConstraintValid(&pVal->elements, pErrCode);
	
	}

	return ret;
}

flag asn1SccBase_JointTransformVector_Encode(const asn1SccBase_JointTransformVector* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccBase_JointTransformVector_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode names */
	    ret = asn1SccBase_JointTransformVector_names_Encode(&pVal->names, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode elements */
	        ret = asn1SccBase_JointTransformVector_elements_Encode(&pVal->elements, pBitStrm, pErrCode, FALSE);
	    
	    }
    }

	return ret;
}

flag asn1SccBase_JointTransformVector_Decode(asn1SccBase_JointTransformVector* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode names */
	ret = asn1SccBase_JointTransformVector_names_Decode(&pVal->names, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode elements */
	    ret = asn1SccBase_JointTransformVector_elements_Decode(&pVal->elements, pBitStrm, pErrCode);
	
	}


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_Wrenches_names_Initialize(asn1SccBase_samples_Wrenches_names* pVal)
{
    *pVal = (asn1SccBase_samples_Wrenches_names) {    .nCount = 1,    .arr = 
    {
        {0,
            {
            }
        }        
    }
};
}
#endif

 
flag asn1SccBase_samples_Wrenches_names_IsConstraintValid(const asn1SccBase_samples_Wrenches_names* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_samples_Wrenches_names);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_samples_Wrenches_names;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_String_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}

flag asn1SccBase_samples_Wrenches_names_Encode(const asn1SccBase_samples_Wrenches_names* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? asn1SccBase_samples_Wrenches_names_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccT_String_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag asn1SccBase_samples_Wrenches_names_Decode(asn1SccBase_samples_Wrenches_names* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : 268435508;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = asn1SccT_String_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_Wrenches_Initialize(asn1SccBase_samples_Wrenches* pVal)
{
    *pVal = (asn1SccBase_samples_Wrenches) {
    .names = {    .nCount = 1,    .arr = 
        {
            {0,
                {
                }
            }        
        }
    },
    .elements = {    .nCount = 1,    .arr = 
        {
            {
                .force = {
                    .data = {    .nCount = 1,    .arr = 
                        {
                            0.00000000000000000000E+000        
                        }
                    }
                },
                .torque = {
                    .data = {    .nCount = 1,    .arr = 
                        {
                            0.00000000000000000000E+000        
                        }
                    }
                }
            }        
        }
    },
    .time = {
        .microseconds = -9223372036854775807LL
    }
};
}
#endif

 
flag asn1SccBase_samples_Wrenches_IsConstraintValid(const asn1SccBase_samples_Wrenches* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccBase_samples_Wrenches_names_IsConstraintValid(&pVal->names, pErrCode);
	if (ret) {
	    ret = asn1SccBase_samples_Wrenches_elements_IsConstraintValid(&pVal->elements, pErrCode);
	    if (ret) {
	        ret = asn1SccBase_Time_IsConstraintValid(&pVal->time, pErrCode);
	    
	    }
	}

	return ret;
}

flag asn1SccBase_samples_Wrenches_Encode(const asn1SccBase_samples_Wrenches* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccBase_samples_Wrenches_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode names */
	    ret = asn1SccBase_samples_Wrenches_names_Encode(&pVal->names, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode elements */
	        ret = asn1SccBase_samples_Wrenches_elements_Encode(&pVal->elements, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode time */
	            ret = asn1SccBase_Time_Encode(&pVal->time, pBitStrm, pErrCode, FALSE);
	        
	        }
	    }
    }

	return ret;
}

flag asn1SccBase_samples_Wrenches_Decode(asn1SccBase_samples_Wrenches* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode names */
	ret = asn1SccBase_samples_Wrenches_names_Decode(&pVal->names, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode elements */
	    ret = asn1SccBase_samples_Wrenches_elements_Decode(&pVal->elements, pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode time */
	        ret = asn1SccBase_Time_Decode(&pVal->time, pBitStrm, pErrCode);
	    
	    }
	}


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_commands_Joints_names_Initialize(asn1SccBase_commands_Joints_names* pVal)
{
    *pVal = (asn1SccBase_commands_Joints_names) {    .nCount = 1,    .arr = 
    {
        {0,
            {
            }
        }        
    }
};
}
#endif

 
flag asn1SccBase_commands_Joints_names_IsConstraintValid(const asn1SccBase_commands_Joints_names* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_commands_Joints_names);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_commands_Joints_names;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_String_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}

flag asn1SccBase_commands_Joints_names_Encode(const asn1SccBase_commands_Joints_names* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? asn1SccBase_commands_Joints_names_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccT_String_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag asn1SccBase_commands_Joints_names_Decode(asn1SccBase_commands_Joints_names* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : 268435509;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = asn1SccT_String_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_commands_Joints_Initialize(asn1SccBase_commands_Joints* pVal)
{
    *pVal = (asn1SccBase_commands_Joints) {
    .names = {    .nCount = 1,    .arr = 
        {
            {0,
                {
                }
            }        
        }
    },
    .elements = {    .nCount = 1,    .arr = 
        {
            {
                .position = 0.00000000000000000000E+000,
                .speed = 0.00000000000000000000E+000,
                .effort = 0.00000000000000000000E+000,
                .raw = 0.00000000000000000000E+000,
                .acceleration = 0.00000000000000000000E+000
            }        
        }
    },
    .time = {
        .microseconds = -9223372036854775807LL
    }
};
}
#endif

 
flag asn1SccBase_commands_Joints_IsConstraintValid(const asn1SccBase_commands_Joints* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccBase_commands_Joints_names_IsConstraintValid(&pVal->names, pErrCode);
	if (ret) {
	    ret = asn1SccBase_JointTrajectory_IsConstraintValid(&pVal->elements, pErrCode);
	    if (ret) {
	        ret = asn1SccBase_Time_IsConstraintValid(&pVal->time, pErrCode);
	    
	    }
	}

	return ret;
}

flag asn1SccBase_commands_Joints_Encode(const asn1SccBase_commands_Joints* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccBase_commands_Joints_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode names */
	    ret = asn1SccBase_commands_Joints_names_Encode(&pVal->names, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode elements */
	        ret = asn1SccBase_JointTrajectory_Encode(&pVal->elements, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode time */
	            ret = asn1SccBase_Time_Encode(&pVal->time, pBitStrm, pErrCode, FALSE);
	        
	        }
	    }
    }

	return ret;
}

flag asn1SccBase_commands_Joints_Decode(asn1SccBase_commands_Joints* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode names */
	ret = asn1SccBase_commands_Joints_names_Decode(&pVal->names, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode elements */
	    ret = asn1SccBase_JointTrajectory_Decode(&pVal->elements, pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode time */
	        ret = asn1SccBase_Time_Decode(&pVal->time, pBitStrm, pErrCode);
	    
	    }
	}


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_NamedVector_Base_JointTrajectory_names_Initialize(asn1SccBase_NamedVector_Base_JointTrajectory_names* pVal)
{
    *pVal = (asn1SccBase_NamedVector_Base_JointTrajectory_names) {    .nCount = 1,    .arr = 
    {
        {0,
            {
            }
        }        
    }
};
}
#endif

 
flag asn1SccBase_NamedVector_Base_JointTrajectory_names_IsConstraintValid(const asn1SccBase_NamedVector_Base_JointTrajectory_names* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_NamedVector_Base_JointTrajectory_names);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_NamedVector_Base_JointTrajectory_names;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_String_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}

flag asn1SccBase_NamedVector_Base_JointTrajectory_names_Encode(const asn1SccBase_NamedVector_Base_JointTrajectory_names* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? asn1SccBase_NamedVector_Base_JointTrajectory_names_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccT_String_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag asn1SccBase_NamedVector_Base_JointTrajectory_names_Decode(asn1SccBase_NamedVector_Base_JointTrajectory_names* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : 268435510;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = asn1SccT_String_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_NamedVector_Base_JointTrajectory_Initialize(asn1SccBase_NamedVector_Base_JointTrajectory* pVal)
{
    *pVal = (asn1SccBase_NamedVector_Base_JointTrajectory) {
    .names = {    .nCount = 1,    .arr = 
        {
            {0,
                {
                }
            }        
        }
    },
    .elements = {    .nCount = 1,    .arr = 
        {
            {    .nCount = 1,    .arr = 
                {
                    {
                        .position = 0.00000000000000000000E+000,
                        .speed = 0.00000000000000000000E+000,
                        .effort = 0.00000000000000000000E+000,
                        .raw = 0.00000000000000000000E+000,
                        .acceleration = 0.00000000000000000000E+000
                    }        
                }
            }        
        }
    }
};
}
#endif

 
flag asn1SccBase_NamedVector_Base_JointTrajectory_IsConstraintValid(const asn1SccBase_NamedVector_Base_JointTrajectory* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccBase_NamedVector_Base_JointTrajectory_names_IsConstraintValid(&pVal->names, pErrCode);
	if (ret) {
	    ret = asn1SccBase_NamedVector_Base_JointTrajectory_elements_IsConstraintValid(&pVal->elements, pErrCode);
	
	}

	return ret;
}

flag asn1SccBase_NamedVector_Base_JointTrajectory_Encode(const asn1SccBase_NamedVector_Base_JointTrajectory* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccBase_NamedVector_Base_JointTrajectory_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode names */
	    ret = asn1SccBase_NamedVector_Base_JointTrajectory_names_Encode(&pVal->names, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode elements */
	        ret = asn1SccBase_NamedVector_Base_JointTrajectory_elements_Encode(&pVal->elements, pBitStrm, pErrCode, FALSE);
	    
	    }
    }

	return ret;
}

flag asn1SccBase_NamedVector_Base_JointTrajectory_Decode(asn1SccBase_NamedVector_Base_JointTrajectory* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode names */
	ret = asn1SccBase_NamedVector_Base_JointTrajectory_names_Decode(&pVal->names, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode elements */
	    ret = asn1SccBase_NamedVector_Base_JointTrajectory_elements_Decode(&pVal->elements, pBitStrm, pErrCode);
	
	}


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_NamedVector_Base_Wrench_names_Initialize(asn1SccBase_NamedVector_Base_Wrench_names* pVal)
{
    *pVal = (asn1SccBase_NamedVector_Base_Wrench_names) {    .nCount = 1,    .arr = 
    {
        {0,
            {
            }
        }        
    }
};
}
#endif

 
flag asn1SccBase_NamedVector_Base_Wrench_names_IsConstraintValid(const asn1SccBase_NamedVector_Base_Wrench_names* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_NamedVector_Base_Wrench_names);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_NamedVector_Base_Wrench_names;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_String_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}

flag asn1SccBase_NamedVector_Base_Wrench_names_Encode(const asn1SccBase_NamedVector_Base_Wrench_names* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? asn1SccBase_NamedVector_Base_Wrench_names_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccT_String_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag asn1SccBase_NamedVector_Base_Wrench_names_Decode(asn1SccBase_NamedVector_Base_Wrench_names* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : 268435511;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = asn1SccT_String_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_NamedVector_Base_Wrench_Initialize(asn1SccBase_NamedVector_Base_Wrench* pVal)
{
    *pVal = (asn1SccBase_NamedVector_Base_Wrench) {
    .names = {    .nCount = 1,    .arr = 
        {
            {0,
                {
                }
            }        
        }
    },
    .elements = {    .nCount = 1,    .arr = 
        {
            {
                .force = {
                    .data = {    .nCount = 1,    .arr = 
                        {
                            0.00000000000000000000E+000        
                        }
                    }
                },
                .torque = {
                    .data = {    .nCount = 1,    .arr = 
                        {
                            0.00000000000000000000E+000        
                        }
                    }
                }
            }        
        }
    }
};
}
#endif

 
flag asn1SccBase_NamedVector_Base_Wrench_IsConstraintValid(const asn1SccBase_NamedVector_Base_Wrench* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccBase_NamedVector_Base_Wrench_names_IsConstraintValid(&pVal->names, pErrCode);
	if (ret) {
	    ret = asn1SccBase_NamedVector_Base_Wrench_elements_IsConstraintValid(&pVal->elements, pErrCode);
	
	}

	return ret;
}

flag asn1SccBase_NamedVector_Base_Wrench_Encode(const asn1SccBase_NamedVector_Base_Wrench* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccBase_NamedVector_Base_Wrench_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode names */
	    ret = asn1SccBase_NamedVector_Base_Wrench_names_Encode(&pVal->names, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode elements */
	        ret = asn1SccBase_NamedVector_Base_Wrench_elements_Encode(&pVal->elements, pBitStrm, pErrCode, FALSE);
	    
	    }
    }

	return ret;
}

flag asn1SccBase_NamedVector_Base_Wrench_Decode(asn1SccBase_NamedVector_Base_Wrench* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode names */
	ret = asn1SccBase_NamedVector_Base_Wrench_names_Decode(&pVal->names, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode elements */
	    ret = asn1SccBase_NamedVector_Base_Wrench_elements_Decode(&pVal->elements, pBitStrm, pErrCode);
	
	}


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_NamedVector_Base_JointState_names_Initialize(asn1SccBase_NamedVector_Base_JointState_names* pVal)
{
    *pVal = (asn1SccBase_NamedVector_Base_JointState_names) {    .nCount = 1,    .arr = 
    {
        {0,
            {
            }
        }        
    }
};
}
#endif

 
flag asn1SccBase_NamedVector_Base_JointState_names_IsConstraintValid(const asn1SccBase_NamedVector_Base_JointState_names* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_NamedVector_Base_JointState_names);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_NamedVector_Base_JointState_names;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_String_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}

flag asn1SccBase_NamedVector_Base_JointState_names_Encode(const asn1SccBase_NamedVector_Base_JointState_names* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? asn1SccBase_NamedVector_Base_JointState_names_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccT_String_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag asn1SccBase_NamedVector_Base_JointState_names_Decode(asn1SccBase_NamedVector_Base_JointState_names* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : 268435512;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = asn1SccT_String_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_NamedVector_Base_JointState_Initialize(asn1SccBase_NamedVector_Base_JointState* pVal)
{
    *pVal = (asn1SccBase_NamedVector_Base_JointState) {
    .names = {    .nCount = 1,    .arr = 
        {
            {0,
                {
                }
            }        
        }
    },
    .elements = {    .nCount = 1,    .arr = 
        {
            {
                .position = 0.00000000000000000000E+000,
                .speed = 0.00000000000000000000E+000,
                .effort = 0.00000000000000000000E+000,
                .raw = 0.00000000000000000000E+000,
                .acceleration = 0.00000000000000000000E+000
            }        
        }
    }
};
}
#endif

 
flag asn1SccBase_NamedVector_Base_JointState_IsConstraintValid(const asn1SccBase_NamedVector_Base_JointState* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccBase_NamedVector_Base_JointState_names_IsConstraintValid(&pVal->names, pErrCode);
	if (ret) {
	    ret = asn1SccBase_JointTrajectory_IsConstraintValid(&pVal->elements, pErrCode);
	
	}

	return ret;
}

flag asn1SccBase_NamedVector_Base_JointState_Encode(const asn1SccBase_NamedVector_Base_JointState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccBase_NamedVector_Base_JointState_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode names */
	    ret = asn1SccBase_NamedVector_Base_JointState_names_Encode(&pVal->names, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode elements */
	        ret = asn1SccBase_JointTrajectory_Encode(&pVal->elements, pBitStrm, pErrCode, FALSE);
	    
	    }
    }

	return ret;
}

flag asn1SccBase_NamedVector_Base_JointState_Decode(asn1SccBase_NamedVector_Base_JointState* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode names */
	ret = asn1SccBase_NamedVector_Base_JointState_names_Decode(&pVal->names, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode elements */
	    ret = asn1SccBase_JointTrajectory_Decode(&pVal->elements, pBitStrm, pErrCode);
	
	}


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_NamedVector_Base_JointLimitRange_names_Initialize(asn1SccBase_NamedVector_Base_JointLimitRange_names* pVal)
{
    *pVal = (asn1SccBase_NamedVector_Base_JointLimitRange_names) {    .nCount = 1,    .arr = 
    {
        {0,
            {
            }
        }        
    }
};
}
#endif

 
flag asn1SccBase_NamedVector_Base_JointLimitRange_names_IsConstraintValid(const asn1SccBase_NamedVector_Base_JointLimitRange_names* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_NamedVector_Base_JointLimitRange_names);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_NamedVector_Base_JointLimitRange_names;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_String_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}

flag asn1SccBase_NamedVector_Base_JointLimitRange_names_Encode(const asn1SccBase_NamedVector_Base_JointLimitRange_names* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? asn1SccBase_NamedVector_Base_JointLimitRange_names_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccT_String_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag asn1SccBase_NamedVector_Base_JointLimitRange_names_Decode(asn1SccBase_NamedVector_Base_JointLimitRange_names* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : 268435513;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = asn1SccT_String_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_NamedVector_Base_JointLimitRange_Initialize(asn1SccBase_NamedVector_Base_JointLimitRange* pVal)
{
    *pVal = (asn1SccBase_NamedVector_Base_JointLimitRange) {
    .names = {    .nCount = 1,    .arr = 
        {
            {0,
                {
                }
            }        
        }
    },
    .elements = {    .nCount = 1,    .arr = 
        {
            {
                .min = {
                    .position = 0.00000000000000000000E+000,
                    .speed = 0.00000000000000000000E+000,
                    .effort = 0.00000000000000000000E+000,
                    .raw = 0.00000000000000000000E+000,
                    .acceleration = 0.00000000000000000000E+000
                },
                .max = {
                    .position = 0.00000000000000000000E+000,
                    .speed = 0.00000000000000000000E+000,
                    .effort = 0.00000000000000000000E+000,
                    .raw = 0.00000000000000000000E+000,
                    .acceleration = 0.00000000000000000000E+000
                }
            }        
        }
    }
};
}
#endif

 
flag asn1SccBase_NamedVector_Base_JointLimitRange_IsConstraintValid(const asn1SccBase_NamedVector_Base_JointLimitRange* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccBase_NamedVector_Base_JointLimitRange_names_IsConstraintValid(&pVal->names, pErrCode);
	if (ret) {
	    ret = asn1SccBase_NamedVector_Base_JointLimitRange_elements_IsConstraintValid(&pVal->elements, pErrCode);
	
	}

	return ret;
}

flag asn1SccBase_NamedVector_Base_JointLimitRange_Encode(const asn1SccBase_NamedVector_Base_JointLimitRange* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccBase_NamedVector_Base_JointLimitRange_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode names */
	    ret = asn1SccBase_NamedVector_Base_JointLimitRange_names_Encode(&pVal->names, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode elements */
	        ret = asn1SccBase_NamedVector_Base_JointLimitRange_elements_Encode(&pVal->elements, pBitStrm, pErrCode, FALSE);
	    
	    }
    }

	return ret;
}

flag asn1SccBase_NamedVector_Base_JointLimitRange_Decode(asn1SccBase_NamedVector_Base_JointLimitRange* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode names */
	ret = asn1SccBase_NamedVector_Base_JointLimitRange_names_Decode(&pVal->names, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode elements */
	    ret = asn1SccBase_NamedVector_Base_JointLimitRange_elements_Decode(&pVal->elements, pBitStrm, pErrCode);
	
	}


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_JointsTrajectory_names_Initialize(asn1SccBase_JointsTrajectory_names* pVal)
{
    *pVal = (asn1SccBase_JointsTrajectory_names) {    .nCount = 1,    .arr = 
    {
        {0,
            {
            }
        }        
    }
};
}
#endif

 
flag asn1SccBase_JointsTrajectory_names_IsConstraintValid(const asn1SccBase_JointsTrajectory_names* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_JointsTrajectory_names);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_JointsTrajectory_names;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_String_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}

flag asn1SccBase_JointsTrajectory_names_Encode(const asn1SccBase_JointsTrajectory_names* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? asn1SccBase_JointsTrajectory_names_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccT_String_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag asn1SccBase_JointsTrajectory_names_Decode(asn1SccBase_JointsTrajectory_names* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : 268435514;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = asn1SccT_String_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_JointsTrajectory_Initialize(asn1SccBase_JointsTrajectory* pVal)
{
    *pVal = (asn1SccBase_JointsTrajectory) {
    .names = {    .nCount = 1,    .arr = 
        {
            {0,
                {
                }
            }        
        }
    },
    .elements = {    .nCount = 1,    .arr = 
        {
            {    .nCount = 1,    .arr = 
                {
                    {
                        .position = 0.00000000000000000000E+000,
                        .speed = 0.00000000000000000000E+000,
                        .effort = 0.00000000000000000000E+000,
                        .raw = 0.00000000000000000000E+000,
                        .acceleration = 0.00000000000000000000E+000
                    }        
                }
            }        
        }
    },
    .times_val = {    .nCount = 1,    .arr = 
        {
            {
                .microseconds = -9223372036854775807LL
            }        
        }
    }
};
}
#endif

 
flag asn1SccBase_JointsTrajectory_IsConstraintValid(const asn1SccBase_JointsTrajectory* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccBase_JointsTrajectory_names_IsConstraintValid(&pVal->names, pErrCode);
	if (ret) {
	    ret = asn1SccBase_JointsTrajectory_elements_IsConstraintValid(&pVal->elements, pErrCode);
	    if (ret) {
	        ret = asn1SccBase_JointsTrajectory_times_val_IsConstraintValid(&pVal->times_val, pErrCode);
	    
	    }
	}

	return ret;
}

flag asn1SccBase_JointsTrajectory_Encode(const asn1SccBase_JointsTrajectory* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccBase_JointsTrajectory_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode names */
	    ret = asn1SccBase_JointsTrajectory_names_Encode(&pVal->names, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode elements */
	        ret = asn1SccBase_JointsTrajectory_elements_Encode(&pVal->elements, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode times_val */
	            ret = asn1SccBase_JointsTrajectory_times_val_Encode(&pVal->times_val, pBitStrm, pErrCode, FALSE);
	        
	        }
	    }
    }

	return ret;
}

flag asn1SccBase_JointsTrajectory_Decode(asn1SccBase_JointsTrajectory* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode names */
	ret = asn1SccBase_JointsTrajectory_names_Decode(&pVal->names, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode elements */
	    ret = asn1SccBase_JointsTrajectory_elements_Decode(&pVal->elements, pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode times_val */
	        ret = asn1SccBase_JointsTrajectory_times_val_Decode(&pVal->times_val, pBitStrm, pErrCode);
	    
	    }
	}


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_JointLimits_names_Initialize(asn1SccBase_JointLimits_names* pVal)
{
    *pVal = (asn1SccBase_JointLimits_names) {    .nCount = 1,    .arr = 
    {
        {0,
            {
            }
        }        
    }
};
}
#endif

 
flag asn1SccBase_JointLimits_names_IsConstraintValid(const asn1SccBase_JointLimits_names* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_JointLimits_names);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_JointLimits_names;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_String_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}

flag asn1SccBase_JointLimits_names_Encode(const asn1SccBase_JointLimits_names* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? asn1SccBase_JointLimits_names_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccT_String_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag asn1SccBase_JointLimits_names_Decode(asn1SccBase_JointLimits_names* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : 268435515;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = asn1SccT_String_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_JointLimits_Initialize(asn1SccBase_JointLimits* pVal)
{
    *pVal = (asn1SccBase_JointLimits) {
    .names = {    .nCount = 1,    .arr = 
        {
            {0,
                {
                }
            }        
        }
    },
    .elements = {    .nCount = 1,    .arr = 
        {
            {
                .min = {
                    .position = 0.00000000000000000000E+000,
                    .speed = 0.00000000000000000000E+000,
                    .effort = 0.00000000000000000000E+000,
                    .raw = 0.00000000000000000000E+000,
                    .acceleration = 0.00000000000000000000E+000
                },
                .max = {
                    .position = 0.00000000000000000000E+000,
                    .speed = 0.00000000000000000000E+000,
                    .effort = 0.00000000000000000000E+000,
                    .raw = 0.00000000000000000000E+000,
                    .acceleration = 0.00000000000000000000E+000
                }
            }        
        }
    }
};
}
#endif

 
flag asn1SccBase_JointLimits_IsConstraintValid(const asn1SccBase_JointLimits* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccBase_JointLimits_names_IsConstraintValid(&pVal->names, pErrCode);
	if (ret) {
	    ret = asn1SccBase_JointLimits_elements_IsConstraintValid(&pVal->elements, pErrCode);
	
	}

	return ret;
}

flag asn1SccBase_JointLimits_Encode(const asn1SccBase_JointLimits* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccBase_JointLimits_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode names */
	    ret = asn1SccBase_JointLimits_names_Encode(&pVal->names, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode elements */
	        ret = asn1SccBase_JointLimits_elements_Encode(&pVal->elements, pBitStrm, pErrCode, FALSE);
	    
	    }
    }

	return ret;
}

flag asn1SccBase_JointLimits_Decode(asn1SccBase_JointLimits* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode names */
	ret = asn1SccBase_JointLimits_names_Decode(&pVal->names, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode elements */
	    ret = asn1SccBase_JointLimits_elements_Decode(&pVal->elements, pBitStrm, pErrCode);
	
	}


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccDummy2Base_T_Initialize(asn1SccDummy2Base_T* pVal)
{
    *pVal = (asn1SccDummy2Base_T) 0;
}
#endif

 
flag asn1SccDummy2Base_T_IsConstraintValid(const asn1SccDummy2Base_T* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccDummyBase_T_IsConstraintValid(pVal, pErrCode);

	return ret;
}

flag asn1SccDummy2Base_T_Encode(const asn1SccDummy2Base_T* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccDummy2Base_T_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = asn1SccDummyBase_T_Encode(pVal, pBitStrm, pErrCode, FALSE);
    }

	return ret;
}

flag asn1SccDummy2Base_T_Decode(asn1SccDummy2Base_T* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = asn1SccDummyBase_T_Decode(pVal, pBitStrm, pErrCode);

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_JointState_MODE_Initialize(asn1SccBase_JointState_MODE* pVal)
{
    *pVal = (asn1SccBase_JointState_MODE) asn1Sccbase_jointstate_mode_acceleration;
}
#endif

 
flag asn1SccBase_JointState_MODE_IsConstraintValid(const asn1SccBase_JointState_MODE* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = ((((((*pVal == asn1Sccbase_jointstate_mode_acceleration) || (*pVal == asn1Sccbase_jointstate_mode_effort)) || (*pVal == asn1Sccbase_jointstate_mode_position)) || (*pVal == asn1Sccbase_jointstate_mode_raw)) || (*pVal == asn1Sccbase_jointstate_mode_speed)) || (*pVal == asn1Sccbase_jointstate_mode_unset));
	*pErrCode = ret ? 0 : ERR_asn1SccBase_JointState_MODE;

	return ret;
}

flag asn1SccBase_JointState_MODE_Encode(const asn1SccBase_JointState_MODE* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccBase_JointState_MODE_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(*pVal) 
	    {
	        case asn1Sccbase_jointstate_mode_acceleration:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 5);
	        	break;
	        case asn1Sccbase_jointstate_mode_effort:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 5);
	        	break;
	        case asn1Sccbase_jointstate_mode_position:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 5);
	        	break;
	        case asn1Sccbase_jointstate_mode_raw:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 5);
	        	break;
	        case asn1Sccbase_jointstate_mode_speed:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 4, 0, 5);
	        	break;
	        case asn1Sccbase_jointstate_mode_unset:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 5, 0, 5);
	        	break;
	        default:
	    	    *pErrCode = 1073741825; //COVERAGE_IGNORE
	    	    ret = FALSE;            //COVERAGE_IGNORE
	    }
    }

	return ret;
}

flag asn1SccBase_JointState_MODE_Decode(asn1SccBase_JointState_MODE* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint enumIndex;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 5);
	*pErrCode = ret ? 0 : 268435516;
	if (ret) {
	    switch(enumIndex) 
	    {
	        case 0: 
	            *pVal = asn1Sccbase_jointstate_mode_acceleration;
	            break;
	        case 1: 
	            *pVal = asn1Sccbase_jointstate_mode_effort;
	            break;
	        case 2: 
	            *pVal = asn1Sccbase_jointstate_mode_position;
	            break;
	        case 3: 
	            *pVal = asn1Sccbase_jointstate_mode_raw;
	            break;
	        case 4: 
	            *pVal = asn1Sccbase_jointstate_mode_speed;
	            break;
	        case 5: 
	            *pVal = asn1Sccbase_jointstate_mode_unset;
	            break;
	        default:
		        *pErrCode = 1073741826;     //COVERAGE_IGNORE
		        ret = FALSE;                //COVERAGE_IGNORE
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_Time_Resolution_Initialize(asn1SccBase_Time_Resolution* pVal)
{
    *pVal = (asn1SccBase_Time_Resolution) asn1Sccbase_time_resolution_microseconds;
}
#endif

 
flag asn1SccBase_Time_Resolution_IsConstraintValid(const asn1SccBase_Time_Resolution* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (((*pVal == asn1Sccbase_time_resolution_microseconds) || (*pVal == asn1Sccbase_time_resolution_milliseconds)) || (*pVal == asn1Sccbase_time_resolution_seconds));
	*pErrCode = ret ? 0 : ERR_asn1SccBase_Time_Resolution;

	return ret;
}

flag asn1SccBase_Time_Resolution_Encode(const asn1SccBase_Time_Resolution* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccBase_Time_Resolution_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(*pVal) 
	    {
	        case asn1Sccbase_time_resolution_microseconds:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 2);
	        	break;
	        case asn1Sccbase_time_resolution_milliseconds:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 2);
	        	break;
	        case asn1Sccbase_time_resolution_seconds:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 2);
	        	break;
	        default:
	    	    *pErrCode = 1073741827; //COVERAGE_IGNORE
	    	    ret = FALSE;            //COVERAGE_IGNORE
	    }
    }

	return ret;
}

flag asn1SccBase_Time_Resolution_Decode(asn1SccBase_Time_Resolution* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint enumIndex;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 2);
	*pErrCode = ret ? 0 : 268435517;
	if (ret) {
	    switch(enumIndex) 
	    {
	        case 0: 
	            *pVal = asn1Sccbase_time_resolution_microseconds;
	            break;
	        case 1: 
	            *pVal = asn1Sccbase_time_resolution_milliseconds;
	            break;
	        case 2: 
	            *pVal = asn1Sccbase_time_resolution_seconds;
	            break;
	        default:
		        *pErrCode = 1073741828;     //COVERAGE_IGNORE
		        ret = FALSE;                //COVERAGE_IGNORE
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_geometry_SplineBase_CoordinateType_Initialize(asn1SccBase_geometry_SplineBase_CoordinateType* pVal)
{
    *pVal = (asn1SccBase_geometry_SplineBase_CoordinateType) asn1Sccbase_geometry_splinebase_coordinatetype_derivative_to_next;
}
#endif

 
flag asn1SccBase_geometry_SplineBase_CoordinateType_IsConstraintValid(const asn1SccBase_geometry_SplineBase_CoordinateType* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = ((((((((*pVal == asn1Sccbase_geometry_splinebase_coordinatetype_derivative_to_next) || (*pVal == asn1Sccbase_geometry_splinebase_coordinatetype_derivative_to_prior)) || (*pVal == asn1Sccbase_geometry_splinebase_coordinatetype_knuckle_point)) || (*pVal == asn1Sccbase_geometry_splinebase_coordinatetype_ordinary_point)) || (*pVal == asn1Sccbase_geometry_splinebase_coordinatetype_second_derivative_to_next)) || (*pVal == asn1Sccbase_geometry_splinebase_coordinatetype_second_derivative_to_prior)) || (*pVal == asn1Sccbase_geometry_splinebase_coordinatetype_tangent_point_for_next)) || (*pVal == asn1Sccbase_geometry_splinebase_coordinatetype_tangent_point_for_prior));
	*pErrCode = ret ? 0 : ERR_asn1SccBase_geometry_SplineBase_CoordinateType;

	return ret;
}

flag asn1SccBase_geometry_SplineBase_CoordinateType_Encode(const asn1SccBase_geometry_SplineBase_CoordinateType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccBase_geometry_SplineBase_CoordinateType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(*pVal) 
	    {
	        case asn1Sccbase_geometry_splinebase_coordinatetype_derivative_to_next:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 7);
	        	break;
	        case asn1Sccbase_geometry_splinebase_coordinatetype_derivative_to_prior:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 7);
	        	break;
	        case asn1Sccbase_geometry_splinebase_coordinatetype_knuckle_point:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 7);
	        	break;
	        case asn1Sccbase_geometry_splinebase_coordinatetype_ordinary_point:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 7);
	        	break;
	        case asn1Sccbase_geometry_splinebase_coordinatetype_second_derivative_to_next:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 4, 0, 7);
	        	break;
	        case asn1Sccbase_geometry_splinebase_coordinatetype_second_derivative_to_prior:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 5, 0, 7);
	        	break;
	        case asn1Sccbase_geometry_splinebase_coordinatetype_tangent_point_for_next:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 6, 0, 7);
	        	break;
	        case asn1Sccbase_geometry_splinebase_coordinatetype_tangent_point_for_prior:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 7, 0, 7);
	        	break;
	        default:
	    	    *pErrCode = 1073741829; //COVERAGE_IGNORE
	    	    ret = FALSE;            //COVERAGE_IGNORE
	    }
    }

	return ret;
}

flag asn1SccBase_geometry_SplineBase_CoordinateType_Decode(asn1SccBase_geometry_SplineBase_CoordinateType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint enumIndex;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 7);
	*pErrCode = ret ? 0 : 268435518;
	if (ret) {
	    switch(enumIndex) 
	    {
	        case 0: 
	            *pVal = asn1Sccbase_geometry_splinebase_coordinatetype_derivative_to_next;
	            break;
	        case 1: 
	            *pVal = asn1Sccbase_geometry_splinebase_coordinatetype_derivative_to_prior;
	            break;
	        case 2: 
	            *pVal = asn1Sccbase_geometry_splinebase_coordinatetype_knuckle_point;
	            break;
	        case 3: 
	            *pVal = asn1Sccbase_geometry_splinebase_coordinatetype_ordinary_point;
	            break;
	        case 4: 
	            *pVal = asn1Sccbase_geometry_splinebase_coordinatetype_second_derivative_to_next;
	            break;
	        case 5: 
	            *pVal = asn1Sccbase_geometry_splinebase_coordinatetype_second_derivative_to_prior;
	            break;
	        case 6: 
	            *pVal = asn1Sccbase_geometry_splinebase_coordinatetype_tangent_point_for_next;
	            break;
	        case 7: 
	            *pVal = asn1Sccbase_geometry_splinebase_coordinatetype_tangent_point_for_prior;
	            break;
	        default:
		        *pErrCode = 1073741830;     //COVERAGE_IGNORE
		        ret = FALSE;                //COVERAGE_IGNORE
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_DepthMap_DEPTH_MEASUREMENT_STATE_Initialize(asn1SccBase_samples_DepthMap_DEPTH_MEASUREMENT_STATE* pVal)
{
    *pVal = (asn1SccBase_samples_DepthMap_DEPTH_MEASUREMENT_STATE) asn1Sccbase_samples_depthmap_depth_measurement_state_measurement_error;
}
#endif

 
flag asn1SccBase_samples_DepthMap_DEPTH_MEASUREMENT_STATE_IsConstraintValid(const asn1SccBase_samples_DepthMap_DEPTH_MEASUREMENT_STATE* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = ((((*pVal == asn1Sccbase_samples_depthmap_depth_measurement_state_measurement_error) || (*pVal == asn1Sccbase_samples_depthmap_depth_measurement_state_too_far)) || (*pVal == asn1Sccbase_samples_depthmap_depth_measurement_state_too_near)) || (*pVal == asn1Sccbase_samples_depthmap_depth_measurement_state_valid_measurement));
	*pErrCode = ret ? 0 : ERR_asn1SccBase_samples_DepthMap_DEPTH_MEASUREMENT_STATE;

	return ret;
}

flag asn1SccBase_samples_DepthMap_DEPTH_MEASUREMENT_STATE_Encode(const asn1SccBase_samples_DepthMap_DEPTH_MEASUREMENT_STATE* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccBase_samples_DepthMap_DEPTH_MEASUREMENT_STATE_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(*pVal) 
	    {
	        case asn1Sccbase_samples_depthmap_depth_measurement_state_measurement_error:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 3);
	        	break;
	        case asn1Sccbase_samples_depthmap_depth_measurement_state_too_far:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 3);
	        	break;
	        case asn1Sccbase_samples_depthmap_depth_measurement_state_too_near:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 3);
	        	break;
	        case asn1Sccbase_samples_depthmap_depth_measurement_state_valid_measurement:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 3);
	        	break;
	        default:
	    	    *pErrCode = 1073741831; //COVERAGE_IGNORE
	    	    ret = FALSE;            //COVERAGE_IGNORE
	    }
    }

	return ret;
}

flag asn1SccBase_samples_DepthMap_DEPTH_MEASUREMENT_STATE_Decode(asn1SccBase_samples_DepthMap_DEPTH_MEASUREMENT_STATE* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint enumIndex;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 3);
	*pErrCode = ret ? 0 : 268435519;
	if (ret) {
	    switch(enumIndex) 
	    {
	        case 0: 
	            *pVal = asn1Sccbase_samples_depthmap_depth_measurement_state_measurement_error;
	            break;
	        case 1: 
	            *pVal = asn1Sccbase_samples_depthmap_depth_measurement_state_too_far;
	            break;
	        case 2: 
	            *pVal = asn1Sccbase_samples_depthmap_depth_measurement_state_too_near;
	            break;
	        case 3: 
	            *pVal = asn1Sccbase_samples_depthmap_depth_measurement_state_valid_measurement;
	            break;
	        default:
		        *pErrCode = 1073741832;     //COVERAGE_IGNORE
		        ret = FALSE;                //COVERAGE_IGNORE
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_DepthMap_PROJECTION_TYPE_Initialize(asn1SccBase_samples_DepthMap_PROJECTION_TYPE* pVal)
{
    *pVal = (asn1SccBase_samples_DepthMap_PROJECTION_TYPE) asn1Sccbase_samples_depthmap_projection_type_planar;
}
#endif

 
flag asn1SccBase_samples_DepthMap_PROJECTION_TYPE_IsConstraintValid(const asn1SccBase_samples_DepthMap_PROJECTION_TYPE* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = ((*pVal == asn1Sccbase_samples_depthmap_projection_type_planar) || (*pVal == asn1Sccbase_samples_depthmap_projection_type_polar));
	*pErrCode = ret ? 0 : ERR_asn1SccBase_samples_DepthMap_PROJECTION_TYPE;

	return ret;
}

flag asn1SccBase_samples_DepthMap_PROJECTION_TYPE_Encode(const asn1SccBase_samples_DepthMap_PROJECTION_TYPE* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccBase_samples_DepthMap_PROJECTION_TYPE_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(*pVal) 
	    {
	        case asn1Sccbase_samples_depthmap_projection_type_planar:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	        	break;
	        case asn1Sccbase_samples_depthmap_projection_type_polar:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	        	break;
	        default:
	    	    *pErrCode = 1073741833; //COVERAGE_IGNORE
	    	    ret = FALSE;            //COVERAGE_IGNORE
	    }
    }

	return ret;
}

flag asn1SccBase_samples_DepthMap_PROJECTION_TYPE_Decode(asn1SccBase_samples_DepthMap_PROJECTION_TYPE* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint enumIndex;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 1);
	*pErrCode = ret ? 0 : 268435520;
	if (ret) {
	    switch(enumIndex) 
	    {
	        case 0: 
	            *pVal = asn1Sccbase_samples_depthmap_projection_type_planar;
	            break;
	        case 1: 
	            *pVal = asn1Sccbase_samples_depthmap_projection_type_polar;
	            break;
	        default:
		        *pErrCode = 1073741834;     //COVERAGE_IGNORE
		        ret = FALSE;                //COVERAGE_IGNORE
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_DepthMap_Initialize(asn1SccBase_samples_DepthMap* pVal)
{
    *pVal = (asn1SccBase_samples_DepthMap) {
    .time = {
        .microseconds = -9223372036854775807LL
    },
    .timestamps = {    .nCount = 1,    .arr = 
        {
            {
                .microseconds = -9223372036854775807LL
            }        
        }
    },
    .vertical_projection = asn1Sccbase_samples_depthmap_projection_type_planar,
    .horizontal_projection = asn1Sccbase_samples_depthmap_projection_type_planar,
    .vertical_interval = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    },
    .horizontal_interval = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    },
    .vertical_size = 0,
    .horizontal_size = 0,
    .distances = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    },
    .remissions = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    }
};
}
#endif

 
flag asn1SccBase_samples_DepthMap_IsConstraintValid(const asn1SccBase_samples_DepthMap* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccBase_Time_IsConstraintValid(&pVal->time, pErrCode);
	if (ret) {
	    ret = asn1SccBase_samples_DepthMap_timestamps_IsConstraintValid(&pVal->timestamps, pErrCode);
	    if (ret) {
	        ret = asn1SccBase_samples_DepthMap_PROJECTION_TYPE_IsConstraintValid(&pVal->vertical_projection, pErrCode);
	        if (ret) {
	            ret = asn1SccBase_samples_DepthMap_PROJECTION_TYPE_IsConstraintValid(&pVal->horizontal_projection, pErrCode);
	            if (ret) {
	                ret = asn1SccBase_samples_DepthMap_vertical_interval_IsConstraintValid(&pVal->vertical_interval, pErrCode);
	                if (ret) {
	                    ret = asn1SccBase_samples_DepthMap_horizontal_interval_IsConstraintValid(&pVal->horizontal_interval, pErrCode);
	                    if (ret) {
	                        ret = asn1SccT_UInt32_IsConstraintValid(&pVal->vertical_size, pErrCode);
	                        if (ret) {
	                            ret = asn1SccT_UInt32_IsConstraintValid(&pVal->horizontal_size, pErrCode);
	                            if (ret) {
	                                ret = asn1SccBase_samples_DepthMap_distances_IsConstraintValid(&pVal->distances, pErrCode);
	                                if (ret) {
	                                    ret = asn1SccBase_samples_DepthMap_remissions_IsConstraintValid(&pVal->remissions, pErrCode);
	                                
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

	return ret;
}

flag asn1SccBase_samples_DepthMap_Encode(const asn1SccBase_samples_DepthMap* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccBase_samples_DepthMap_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode time */
	    ret = asn1SccBase_Time_Encode(&pVal->time, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode timestamps */
	        ret = asn1SccBase_samples_DepthMap_timestamps_Encode(&pVal->timestamps, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode vertical_projection */
	            ret = asn1SccBase_samples_DepthMap_PROJECTION_TYPE_Encode(&pVal->vertical_projection, pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode horizontal_projection */
	                ret = asn1SccBase_samples_DepthMap_PROJECTION_TYPE_Encode(&pVal->horizontal_projection, pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode vertical_interval */
	                    ret = asn1SccBase_samples_DepthMap_vertical_interval_Encode(&pVal->vertical_interval, pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode horizontal_interval */
	                        ret = asn1SccBase_samples_DepthMap_horizontal_interval_Encode(&pVal->horizontal_interval, pBitStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode vertical_size */
	                            ret = asn1SccT_UInt32_Encode(&pVal->vertical_size, pBitStrm, pErrCode, FALSE);
	                            if (ret) {
	                                /*Encode horizontal_size */
	                                ret = asn1SccT_UInt32_Encode(&pVal->horizontal_size, pBitStrm, pErrCode, FALSE);
	                                if (ret) {
	                                    /*Encode distances */
	                                    ret = asn1SccBase_samples_DepthMap_distances_Encode(&pVal->distances, pBitStrm, pErrCode, FALSE);
	                                    if (ret) {
	                                        /*Encode remissions */
	                                        ret = asn1SccBase_samples_DepthMap_remissions_Encode(&pVal->remissions, pBitStrm, pErrCode, FALSE);
	                                    
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
    }

	return ret;
}

flag asn1SccBase_samples_DepthMap_Decode(asn1SccBase_samples_DepthMap* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode time */
	ret = asn1SccBase_Time_Decode(&pVal->time, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode timestamps */
	    ret = asn1SccBase_samples_DepthMap_timestamps_Decode(&pVal->timestamps, pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode vertical_projection */
	        ret = asn1SccBase_samples_DepthMap_PROJECTION_TYPE_Decode(&pVal->vertical_projection, pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode horizontal_projection */
	            ret = asn1SccBase_samples_DepthMap_PROJECTION_TYPE_Decode(&pVal->horizontal_projection, pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode vertical_interval */
	                ret = asn1SccBase_samples_DepthMap_vertical_interval_Decode(&pVal->vertical_interval, pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode horizontal_interval */
	                    ret = asn1SccBase_samples_DepthMap_horizontal_interval_Decode(&pVal->horizontal_interval, pBitStrm, pErrCode);
	                    if (ret) {
	                        /*Decode vertical_size */
	                        ret = asn1SccT_UInt32_Decode(&pVal->vertical_size, pBitStrm, pErrCode);
	                        if (ret) {
	                            /*Decode horizontal_size */
	                            ret = asn1SccT_UInt32_Decode(&pVal->horizontal_size, pBitStrm, pErrCode);
	                            if (ret) {
	                                /*Decode distances */
	                                ret = asn1SccBase_samples_DepthMap_distances_Decode(&pVal->distances, pBitStrm, pErrCode);
	                                if (ret) {
	                                    /*Decode remissions */
	                                    ret = asn1SccBase_samples_DepthMap_remissions_Decode(&pVal->remissions, pBitStrm, pErrCode);
	                                
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	}


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_DepthMap_UNIT_AXIS_Initialize(asn1SccBase_samples_DepthMap_UNIT_AXIS* pVal)
{
    *pVal = (asn1SccBase_samples_DepthMap_UNIT_AXIS) asn1Sccbase_samples_depthmap_unit_axis_unit_x;
}
#endif

 
flag asn1SccBase_samples_DepthMap_UNIT_AXIS_IsConstraintValid(const asn1SccBase_samples_DepthMap_UNIT_AXIS* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (((*pVal == asn1Sccbase_samples_depthmap_unit_axis_unit_x) || (*pVal == asn1Sccbase_samples_depthmap_unit_axis_unit_y)) || (*pVal == asn1Sccbase_samples_depthmap_unit_axis_unit_z));
	*pErrCode = ret ? 0 : ERR_asn1SccBase_samples_DepthMap_UNIT_AXIS;

	return ret;
}

flag asn1SccBase_samples_DepthMap_UNIT_AXIS_Encode(const asn1SccBase_samples_DepthMap_UNIT_AXIS* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccBase_samples_DepthMap_UNIT_AXIS_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(*pVal) 
	    {
	        case asn1Sccbase_samples_depthmap_unit_axis_unit_x:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 2);
	        	break;
	        case asn1Sccbase_samples_depthmap_unit_axis_unit_y:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 2);
	        	break;
	        case asn1Sccbase_samples_depthmap_unit_axis_unit_z:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 2);
	        	break;
	        default:
	    	    *pErrCode = 1073741835; //COVERAGE_IGNORE
	    	    ret = FALSE;            //COVERAGE_IGNORE
	    }
    }

	return ret;
}

flag asn1SccBase_samples_DepthMap_UNIT_AXIS_Decode(asn1SccBase_samples_DepthMap_UNIT_AXIS* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint enumIndex;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 2);
	*pErrCode = ret ? 0 : 268435521;
	if (ret) {
	    switch(enumIndex) 
	    {
	        case 0: 
	            *pVal = asn1Sccbase_samples_depthmap_unit_axis_unit_x;
	            break;
	        case 1: 
	            *pVal = asn1Sccbase_samples_depthmap_unit_axis_unit_y;
	            break;
	        case 2: 
	            *pVal = asn1Sccbase_samples_depthmap_unit_axis_unit_z;
	            break;
	        default:
		        *pErrCode = 1073741836;     //COVERAGE_IGNORE
		        ret = FALSE;                //COVERAGE_IGNORE
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_LASER_RANGE_ERRORS_Initialize(asn1SccBase_samples_LASER_RANGE_ERRORS* pVal)
{
    *pVal = (asn1SccBase_samples_LASER_RANGE_ERRORS) asn1Sccbase_samples_laser_range_errors_end_laser_range_errors;
}
#endif

 
flag asn1SccBase_samples_LASER_RANGE_ERRORS_IsConstraintValid(const asn1SccBase_samples_LASER_RANGE_ERRORS* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = ((((((*pVal == asn1Sccbase_samples_laser_range_errors_end_laser_range_errors) || (*pVal == asn1Sccbase_samples_laser_range_errors_max_range_error)) || (*pVal == asn1Sccbase_samples_laser_range_errors_measurement_error)) || (*pVal == asn1Sccbase_samples_laser_range_errors_other_range_errors)) || (*pVal == asn1Sccbase_samples_laser_range_errors_too_far)) || (*pVal == asn1Sccbase_samples_laser_range_errors_too_near));
	*pErrCode = ret ? 0 : ERR_asn1SccBase_samples_LASER_RANGE_ERRORS;

	return ret;
}

flag asn1SccBase_samples_LASER_RANGE_ERRORS_Encode(const asn1SccBase_samples_LASER_RANGE_ERRORS* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccBase_samples_LASER_RANGE_ERRORS_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(*pVal) 
	    {
	        case asn1Sccbase_samples_laser_range_errors_end_laser_range_errors:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 5);
	        	break;
	        case asn1Sccbase_samples_laser_range_errors_max_range_error:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 5);
	        	break;
	        case asn1Sccbase_samples_laser_range_errors_measurement_error:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 5);
	        	break;
	        case asn1Sccbase_samples_laser_range_errors_other_range_errors:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 5);
	        	break;
	        case asn1Sccbase_samples_laser_range_errors_too_far:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 4, 0, 5);
	        	break;
	        case asn1Sccbase_samples_laser_range_errors_too_near:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 5, 0, 5);
	        	break;
	        default:
	    	    *pErrCode = 1073741837; //COVERAGE_IGNORE
	    	    ret = FALSE;            //COVERAGE_IGNORE
	    }
    }

	return ret;
}

flag asn1SccBase_samples_LASER_RANGE_ERRORS_Decode(asn1SccBase_samples_LASER_RANGE_ERRORS* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint enumIndex;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 5);
	*pErrCode = ret ? 0 : 268435522;
	if (ret) {
	    switch(enumIndex) 
	    {
	        case 0: 
	            *pVal = asn1Sccbase_samples_laser_range_errors_end_laser_range_errors;
	            break;
	        case 1: 
	            *pVal = asn1Sccbase_samples_laser_range_errors_max_range_error;
	            break;
	        case 2: 
	            *pVal = asn1Sccbase_samples_laser_range_errors_measurement_error;
	            break;
	        case 3: 
	            *pVal = asn1Sccbase_samples_laser_range_errors_other_range_errors;
	            break;
	        case 4: 
	            *pVal = asn1Sccbase_samples_laser_range_errors_too_far;
	            break;
	        case 5: 
	            *pVal = asn1Sccbase_samples_laser_range_errors_too_near;
	            break;
	        default:
		        *pErrCode = 1073741838;     //COVERAGE_IGNORE
		        ret = FALSE;                //COVERAGE_IGNORE
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_frame_frame_mode_t_Initialize(asn1SccBase_samples_frame_frame_mode_t* pVal)
{
    *pVal = (asn1SccBase_samples_frame_frame_mode_t) asn1Sccbase_samples_frame_frame_mode_t_compressed_modes;
}
#endif

 
flag asn1SccBase_samples_frame_frame_mode_t_IsConstraintValid(const asn1SccBase_samples_frame_frame_mode_t* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = ((((((((((((((((*pVal == asn1Sccbase_samples_frame_frame_mode_t_compressed_modes) || (*pVal == asn1Sccbase_samples_frame_frame_mode_t_mode_bayer)) || (*pVal == asn1Sccbase_samples_frame_frame_mode_t_mode_bayer_bggr)) || (*pVal == asn1Sccbase_samples_frame_frame_mode_t_mode_bayer_gbrg)) || (*pVal == asn1Sccbase_samples_frame_frame_mode_t_mode_bayer_grbg)) || (*pVal == asn1Sccbase_samples_frame_frame_mode_t_mode_bayer_rggb)) || (*pVal == asn1Sccbase_samples_frame_frame_mode_t_mode_bgr)) || (*pVal == asn1Sccbase_samples_frame_frame_mode_t_mode_grayscale)) || (*pVal == asn1Sccbase_samples_frame_frame_mode_t_mode_jpeg)) || (*pVal == asn1Sccbase_samples_frame_frame_mode_t_mode_pjpg)) || (*pVal == asn1Sccbase_samples_frame_frame_mode_t_mode_png)) || (*pVal == asn1Sccbase_samples_frame_frame_mode_t_mode_rgb)) || (*pVal == asn1Sccbase_samples_frame_frame_mode_t_mode_rgb32)) || (*pVal == asn1Sccbase_samples_frame_frame_mode_t_mode_undefined)) || (*pVal == asn1Sccbase_samples_frame_frame_mode_t_mode_uyvy)) || (*pVal == asn1Sccbase_samples_frame_frame_mode_t_raw_modes));
	*pErrCode = ret ? 0 : ERR_asn1SccBase_samples_frame_frame_mode_t;

	return ret;
}

flag asn1SccBase_samples_frame_frame_mode_t_Encode(const asn1SccBase_samples_frame_frame_mode_t* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccBase_samples_frame_frame_mode_t_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(*pVal) 
	    {
	        case asn1Sccbase_samples_frame_frame_mode_t_compressed_modes:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 15);
	        	break;
	        case asn1Sccbase_samples_frame_frame_mode_t_mode_bayer:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 15);
	        	break;
	        case asn1Sccbase_samples_frame_frame_mode_t_mode_bayer_bggr:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 15);
	        	break;
	        case asn1Sccbase_samples_frame_frame_mode_t_mode_bayer_gbrg:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 15);
	        	break;
	        case asn1Sccbase_samples_frame_frame_mode_t_mode_bayer_grbg:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 4, 0, 15);
	        	break;
	        case asn1Sccbase_samples_frame_frame_mode_t_mode_bayer_rggb:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 5, 0, 15);
	        	break;
	        case asn1Sccbase_samples_frame_frame_mode_t_mode_bgr:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 6, 0, 15);
	        	break;
	        case asn1Sccbase_samples_frame_frame_mode_t_mode_grayscale:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 7, 0, 15);
	        	break;
	        case asn1Sccbase_samples_frame_frame_mode_t_mode_jpeg:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 8, 0, 15);
	        	break;
	        case asn1Sccbase_samples_frame_frame_mode_t_mode_pjpg:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 9, 0, 15);
	        	break;
	        case asn1Sccbase_samples_frame_frame_mode_t_mode_png:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 10, 0, 15);
	        	break;
	        case asn1Sccbase_samples_frame_frame_mode_t_mode_rgb:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 11, 0, 15);
	        	break;
	        case asn1Sccbase_samples_frame_frame_mode_t_mode_rgb32:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 12, 0, 15);
	        	break;
	        case asn1Sccbase_samples_frame_frame_mode_t_mode_undefined:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 13, 0, 15);
	        	break;
	        case asn1Sccbase_samples_frame_frame_mode_t_mode_uyvy:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 14, 0, 15);
	        	break;
	        case asn1Sccbase_samples_frame_frame_mode_t_raw_modes:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 15, 0, 15);
	        	break;
	        default:
	    	    *pErrCode = 1073741839; //COVERAGE_IGNORE
	    	    ret = FALSE;            //COVERAGE_IGNORE
	    }
    }

	return ret;
}

flag asn1SccBase_samples_frame_frame_mode_t_Decode(asn1SccBase_samples_frame_frame_mode_t* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint enumIndex;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 15);
	*pErrCode = ret ? 0 : 268435523;
	if (ret) {
	    switch(enumIndex) 
	    {
	        case 0: 
	            *pVal = asn1Sccbase_samples_frame_frame_mode_t_compressed_modes;
	            break;
	        case 1: 
	            *pVal = asn1Sccbase_samples_frame_frame_mode_t_mode_bayer;
	            break;
	        case 2: 
	            *pVal = asn1Sccbase_samples_frame_frame_mode_t_mode_bayer_bggr;
	            break;
	        case 3: 
	            *pVal = asn1Sccbase_samples_frame_frame_mode_t_mode_bayer_gbrg;
	            break;
	        case 4: 
	            *pVal = asn1Sccbase_samples_frame_frame_mode_t_mode_bayer_grbg;
	            break;
	        case 5: 
	            *pVal = asn1Sccbase_samples_frame_frame_mode_t_mode_bayer_rggb;
	            break;
	        case 6: 
	            *pVal = asn1Sccbase_samples_frame_frame_mode_t_mode_bgr;
	            break;
	        case 7: 
	            *pVal = asn1Sccbase_samples_frame_frame_mode_t_mode_grayscale;
	            break;
	        case 8: 
	            *pVal = asn1Sccbase_samples_frame_frame_mode_t_mode_jpeg;
	            break;
	        case 9: 
	            *pVal = asn1Sccbase_samples_frame_frame_mode_t_mode_pjpg;
	            break;
	        case 10: 
	            *pVal = asn1Sccbase_samples_frame_frame_mode_t_mode_png;
	            break;
	        case 11: 
	            *pVal = asn1Sccbase_samples_frame_frame_mode_t_mode_rgb;
	            break;
	        case 12: 
	            *pVal = asn1Sccbase_samples_frame_frame_mode_t_mode_rgb32;
	            break;
	        case 13: 
	            *pVal = asn1Sccbase_samples_frame_frame_mode_t_mode_undefined;
	            break;
	        case 14: 
	            *pVal = asn1Sccbase_samples_frame_frame_mode_t_mode_uyvy;
	            break;
	        case 15: 
	            *pVal = asn1Sccbase_samples_frame_frame_mode_t_raw_modes;
	            break;
	        default:
		        *pErrCode = 1073741840;     //COVERAGE_IGNORE
		        ret = FALSE;                //COVERAGE_IGNORE
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_frame_frame_status_t_Initialize(asn1SccBase_samples_frame_frame_status_t* pVal)
{
    *pVal = (asn1SccBase_samples_frame_frame_status_t) asn1Sccbase_samples_frame_frame_status_t_status_empty;
}
#endif

 
flag asn1SccBase_samples_frame_frame_status_t_IsConstraintValid(const asn1SccBase_samples_frame_frame_status_t* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (((*pVal == asn1Sccbase_samples_frame_frame_status_t_status_empty) || (*pVal == asn1Sccbase_samples_frame_frame_status_t_status_invalid)) || (*pVal == asn1Sccbase_samples_frame_frame_status_t_status_valid));
	*pErrCode = ret ? 0 : ERR_asn1SccBase_samples_frame_frame_status_t;

	return ret;
}

flag asn1SccBase_samples_frame_frame_status_t_Encode(const asn1SccBase_samples_frame_frame_status_t* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccBase_samples_frame_frame_status_t_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(*pVal) 
	    {
	        case asn1Sccbase_samples_frame_frame_status_t_status_empty:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 2);
	        	break;
	        case asn1Sccbase_samples_frame_frame_status_t_status_invalid:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 2);
	        	break;
	        case asn1Sccbase_samples_frame_frame_status_t_status_valid:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 2);
	        	break;
	        default:
	    	    *pErrCode = 1073741841; //COVERAGE_IGNORE
	    	    ret = FALSE;            //COVERAGE_IGNORE
	    }
    }

	return ret;
}

flag asn1SccBase_samples_frame_frame_status_t_Decode(asn1SccBase_samples_frame_frame_status_t* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint enumIndex;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 2);
	*pErrCode = ret ? 0 : 268435524;
	if (ret) {
	    switch(enumIndex) 
	    {
	        case 0: 
	            *pVal = asn1Sccbase_samples_frame_frame_status_t_status_empty;
	            break;
	        case 1: 
	            *pVal = asn1Sccbase_samples_frame_frame_status_t_status_invalid;
	            break;
	        case 2: 
	            *pVal = asn1Sccbase_samples_frame_frame_status_t_status_valid;
	            break;
	        default:
		        *pErrCode = 1073741842;     //COVERAGE_IGNORE
		        ret = FALSE;                //COVERAGE_IGNORE
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccWrappers_geometry_SplineType_Initialize(asn1SccWrappers_geometry_SplineType* pVal)
{
    *pVal = (asn1SccWrappers_geometry_SplineType) asn1Sccwrappers_geometry_splinetype_degenerate;
}
#endif

 
flag asn1SccWrappers_geometry_SplineType_IsConstraintValid(const asn1SccWrappers_geometry_SplineType* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (((((*pVal == asn1Sccwrappers_geometry_splinetype_degenerate) || (*pVal == asn1Sccwrappers_geometry_splinetype_polynomial_bezier)) || (*pVal == asn1Sccwrappers_geometry_splinetype_polynomial_bspline)) || (*pVal == asn1Sccwrappers_geometry_splinetype_rational_bezier)) || (*pVal == asn1Sccwrappers_geometry_splinetype_rational_bspline));
	*pErrCode = ret ? 0 : ERR_asn1SccWrappers_geometry_SplineType;

	return ret;
}

flag asn1SccWrappers_geometry_SplineType_Encode(const asn1SccWrappers_geometry_SplineType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccWrappers_geometry_SplineType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(*pVal) 
	    {
	        case asn1Sccwrappers_geometry_splinetype_degenerate:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 4);
	        	break;
	        case asn1Sccwrappers_geometry_splinetype_polynomial_bezier:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 4);
	        	break;
	        case asn1Sccwrappers_geometry_splinetype_polynomial_bspline:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 4);
	        	break;
	        case asn1Sccwrappers_geometry_splinetype_rational_bezier:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 4);
	        	break;
	        case asn1Sccwrappers_geometry_splinetype_rational_bspline:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 4, 0, 4);
	        	break;
	        default:
	    	    *pErrCode = 1073741843; //COVERAGE_IGNORE
	    	    ret = FALSE;            //COVERAGE_IGNORE
	    }
    }

	return ret;
}

flag asn1SccWrappers_geometry_SplineType_Decode(asn1SccWrappers_geometry_SplineType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint enumIndex;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 4);
	*pErrCode = ret ? 0 : 268435525;
	if (ret) {
	    switch(enumIndex) 
	    {
	        case 0: 
	            *pVal = asn1Sccwrappers_geometry_splinetype_degenerate;
	            break;
	        case 1: 
	            *pVal = asn1Sccwrappers_geometry_splinetype_polynomial_bezier;
	            break;
	        case 2: 
	            *pVal = asn1Sccwrappers_geometry_splinetype_polynomial_bspline;
	            break;
	        case 3: 
	            *pVal = asn1Sccwrappers_geometry_splinetype_rational_bezier;
	            break;
	        case 4: 
	            *pVal = asn1Sccwrappers_geometry_splinetype_rational_bspline;
	            break;
	        default:
		        *pErrCode = 1073741844;     //COVERAGE_IGNORE
		        ret = FALSE;                //COVERAGE_IGNORE
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccWrappers_geometry_Spline_Initialize(asn1SccWrappers_geometry_Spline* pVal)
{
    *pVal = (asn1SccWrappers_geometry_Spline) {
    .geometric_resolution = 0.00000000000000000000E+000,
    .dimension = -2147483648LL,
    .curve_order = -2147483648LL,
    .kind = asn1Sccwrappers_geometry_splinetype_degenerate,
    .knots = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    },
    .vertices = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    }
};
}
#endif

 
flag asn1SccWrappers_geometry_Spline_IsConstraintValid(const asn1SccWrappers_geometry_Spline* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccT_Double_IsConstraintValid(&pVal->geometric_resolution, pErrCode);
	if (ret) {
	    ret = asn1SccT_Int32_IsConstraintValid(&pVal->dimension, pErrCode);
	    if (ret) {
	        ret = asn1SccT_Int32_IsConstraintValid(&pVal->curve_order, pErrCode);
	        if (ret) {
	            ret = asn1SccWrappers_geometry_SplineType_IsConstraintValid(&pVal->kind, pErrCode);
	            if (ret) {
	                ret = asn1SccWrappers_geometry_Spline_knots_IsConstraintValid(&pVal->knots, pErrCode);
	                if (ret) {
	                    ret = asn1SccWrappers_geometry_Spline_vertices_IsConstraintValid(&pVal->vertices, pErrCode);
	                
	                }
	            }
	        }
	    }
	}

	return ret;
}

flag asn1SccWrappers_geometry_Spline_Encode(const asn1SccWrappers_geometry_Spline* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccWrappers_geometry_Spline_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode geometric_resolution */
	    ret = asn1SccT_Double_Encode(&pVal->geometric_resolution, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode dimension */
	        ret = asn1SccT_Int32_Encode(&pVal->dimension, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode curve_order */
	            ret = asn1SccT_Int32_Encode(&pVal->curve_order, pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode kind */
	                ret = asn1SccWrappers_geometry_SplineType_Encode(&pVal->kind, pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode knots */
	                    ret = asn1SccWrappers_geometry_Spline_knots_Encode(&pVal->knots, pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode vertices */
	                        ret = asn1SccWrappers_geometry_Spline_vertices_Encode(&pVal->vertices, pBitStrm, pErrCode, FALSE);
	                    
	                    }
	                }
	            }
	        }
	    }
    }

	return ret;
}

flag asn1SccWrappers_geometry_Spline_Decode(asn1SccWrappers_geometry_Spline* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode geometric_resolution */
	ret = asn1SccT_Double_Decode(&pVal->geometric_resolution, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode dimension */
	    ret = asn1SccT_Int32_Decode(&pVal->dimension, pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode curve_order */
	        ret = asn1SccT_Int32_Decode(&pVal->curve_order, pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode kind */
	            ret = asn1SccWrappers_geometry_SplineType_Decode(&pVal->kind, pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode knots */
	                ret = asn1SccWrappers_geometry_Spline_knots_Decode(&pVal->knots, pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode vertices */
	                    ret = asn1SccWrappers_geometry_Spline_vertices_Decode(&pVal->vertices, pBitStrm, pErrCode);
	                
	                }
	            }
	        }
	    }
	}


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_Trajectory_Initialize(asn1SccBase_Trajectory* pVal)
{
    *pVal = (asn1SccBase_Trajectory) {
    .speed = 0.00000000000000000000E+000,
    .spline = {
        .geometric_resolution = 0.00000000000000000000E+000,
        .dimension = -2147483648LL,
        .curve_order = -2147483648LL,
        .kind = asn1Sccwrappers_geometry_splinetype_degenerate,
        .knots = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        },
        .vertices = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    }
};
}
#endif

 
flag asn1SccBase_Trajectory_IsConstraintValid(const asn1SccBase_Trajectory* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccT_Double_IsConstraintValid(&pVal->speed, pErrCode);
	if (ret) {
	    ret = asn1SccWrappers_geometry_Spline_IsConstraintValid(&pVal->spline, pErrCode);
	
	}

	return ret;
}

flag asn1SccBase_Trajectory_Encode(const asn1SccBase_Trajectory* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccBase_Trajectory_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode speed */
	    ret = asn1SccT_Double_Encode(&pVal->speed, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode spline */
	        ret = asn1SccWrappers_geometry_Spline_Encode(&pVal->spline, pBitStrm, pErrCode, FALSE);
	    
	    }
    }

	return ret;
}

flag asn1SccBase_Trajectory_Decode(asn1SccBase_Trajectory* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode speed */
	ret = asn1SccT_Double_Decode(&pVal->speed, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode spline */
	    ret = asn1SccWrappers_geometry_Spline_Decode(&pVal->spline, pBitStrm, pErrCode);
	
	}


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_Trajectory_m_Initialize(asn1SccBase_Trajectory_m* pVal)
{
    *pVal = (asn1SccBase_Trajectory_m) {
    .speed = 0.00000000000000000000E+000,
    .spline = {
        .geometric_resolution = 0.00000000000000000000E+000,
        .dimension = -2147483648LL,
        .curve_order = -2147483648LL,
        .kind = asn1Sccwrappers_geometry_splinetype_degenerate,
        .knots = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        },
        .vertices = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }
    }
};
}
#endif

 
flag asn1SccBase_Trajectory_m_IsConstraintValid(const asn1SccBase_Trajectory_m* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccT_Double_IsConstraintValid(&pVal->speed, pErrCode);
	if (ret) {
	    ret = asn1SccWrappers_geometry_Spline_IsConstraintValid(&pVal->spline, pErrCode);
	
	}

	return ret;
}

flag asn1SccBase_Trajectory_m_Encode(const asn1SccBase_Trajectory_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccBase_Trajectory_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode speed */
	    ret = asn1SccT_Double_Encode(&pVal->speed, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode spline */
	        ret = asn1SccWrappers_geometry_Spline_Encode(&pVal->spline, pBitStrm, pErrCode, FALSE);
	    
	    }
    }

	return ret;
}

flag asn1SccBase_Trajectory_m_Decode(asn1SccBase_Trajectory_m* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode speed */
	ret = asn1SccT_Double_Decode(&pVal->speed, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode spline */
	    ret = asn1SccWrappers_geometry_Spline_Decode(&pVal->spline, pBitStrm, pErrCode);
	
	}


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccStd_orogen_typekits_mtype_std_vector_base_Trajectory_Initialize(asn1SccStd_orogen_typekits_mtype_std_vector_base_Trajectory* pVal)
{
    *pVal = (asn1SccStd_orogen_typekits_mtype_std_vector_base_Trajectory) {    .nCount = 1,    .arr = 
    {
        {
            .speed = 0.00000000000000000000E+000,
            .spline = {
                .geometric_resolution = 0.00000000000000000000E+000,
                .dimension = -2147483648LL,
                .curve_order = -2147483648LL,
                .kind = asn1Sccwrappers_geometry_splinetype_degenerate,
                .knots = {    .nCount = 1,    .arr = 
                    {
                        0.00000000000000000000E+000        
                    }
                },
                .vertices = {    .nCount = 1,    .arr = 
                    {
                        0.00000000000000000000E+000        
                    }
                }
            }
        }        
    }
};
}
#endif

 
flag asn1SccStd_orogen_typekits_mtype_std_vector_base_Trajectory_IsConstraintValid(const asn1SccStd_orogen_typekits_mtype_std_vector_base_Trajectory* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numStd_orogen_typekits_mtype_std_vector_base_Trajectory);
	*pErrCode = ret ? 0 : ERR_asn1SccStd_orogen_typekits_mtype_std_vector_base_Trajectory;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccBase_Trajectory_m_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}

flag asn1SccStd_orogen_typekits_mtype_std_vector_base_Trajectory_Encode(const asn1SccStd_orogen_typekits_mtype_std_vector_base_Trajectory* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? asn1SccStd_orogen_typekits_mtype_std_vector_base_Trajectory_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = asn1SccBase_Trajectory_m_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag asn1SccStd_orogen_typekits_mtype_std_vector_base_Trajectory_Decode(asn1SccStd_orogen_typekits_mtype_std_vector_base_Trajectory* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : 268435526;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = asn1SccBase_Trajectory_m_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_frame_Frame_image_Initialize(asn1SccBase_samples_frame_Frame_image* pVal)
{
    *pVal = (asn1SccBase_samples_frame_Frame_image) {1,
    {
        0x00
    }
};
}
#endif

 
flag asn1SccBase_samples_frame_Frame_image_IsConstraintValid(const asn1SccBase_samples_frame_Frame_image* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_samples_frame_Frame_image);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_samples_frame_Frame_image;

	return ret;
}

flag asn1SccBase_samples_frame_Frame_image_Encode(const asn1SccBase_samples_frame_Frame_image* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? asn1SccBase_samples_frame_Frame_image_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	BitStream_AppendByte0(pBitStrm, pVal->arr[i1]);
	    }
    }

	return ret;
}

flag asn1SccBase_samples_frame_Frame_image_Decode(asn1SccBase_samples_frame_Frame_image* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : 268435527;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = BitStream_ReadByte(pBitStrm, &pVal->arr[i1]); 
		*pErrCode = ret ? 0 : 268435528;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_frame_Frame_Initialize(asn1SccBase_samples_frame_Frame* pVal)
{
    *pVal = (asn1SccBase_samples_frame_Frame) {
    .time = {
        .microseconds = -9223372036854775807LL
    },
    .received_time = {
        .microseconds = -9223372036854775807LL
    },
    .image = {1,
        {
            0x00
        }
    },
    .attributes = {    .nCount = 1,    .arr = 
        {
            {
                .data = {0,
                    {
                    }
                },
                .name_val = {0,
                    {
                    }
                }
            }        
        }
    },
    .size_val = {
        .width = 0,
        .height = 0
    },
    .data_depth = 0,
    .pixel_size = 0,
    .row_size = 0,
    .frame_mode = asn1Sccbase_samples_frame_frame_mode_t_compressed_modes,
    .frame_status = asn1Sccbase_samples_frame_frame_status_t_status_empty
};
}
#endif

 
flag asn1SccBase_samples_frame_Frame_IsConstraintValid(const asn1SccBase_samples_frame_Frame* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccBase_Time_IsConstraintValid(&pVal->time, pErrCode);
	if (ret) {
	    ret = asn1SccBase_Time_IsConstraintValid(&pVal->received_time, pErrCode);
	    if (ret) {
	        ret = asn1SccBase_samples_frame_Frame_image_IsConstraintValid(&pVal->image, pErrCode);
	        if (ret) {
	            ret = asn1SccBase_samples_frame_Frame_attributes_IsConstraintValid(&pVal->attributes, pErrCode);
	            if (ret) {
	                ret = asn1SccBase_samples_frame_frame_size_t_IsConstraintValid(&pVal->size_val, pErrCode);
	                if (ret) {
	                    ret = asn1SccT_UInt32_IsConstraintValid(&pVal->data_depth, pErrCode);
	                    if (ret) {
	                        ret = asn1SccT_UInt32_IsConstraintValid(&pVal->pixel_size, pErrCode);
	                        if (ret) {
	                            ret = asn1SccT_UInt32_IsConstraintValid(&pVal->row_size, pErrCode);
	                            if (ret) {
	                                ret = asn1SccBase_samples_frame_frame_mode_t_IsConstraintValid(&pVal->frame_mode, pErrCode);
	                                if (ret) {
	                                    ret = asn1SccBase_samples_frame_frame_status_t_IsConstraintValid(&pVal->frame_status, pErrCode);
	                                
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

	return ret;
}

flag asn1SccBase_samples_frame_Frame_Encode(const asn1SccBase_samples_frame_Frame* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccBase_samples_frame_Frame_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode time */
	    ret = asn1SccBase_Time_Encode(&pVal->time, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode received_time */
	        ret = asn1SccBase_Time_Encode(&pVal->received_time, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode image */
	            ret = asn1SccBase_samples_frame_Frame_image_Encode(&pVal->image, pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode attributes */
	                ret = asn1SccBase_samples_frame_Frame_attributes_Encode(&pVal->attributes, pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode size_val */
	                    ret = asn1SccBase_samples_frame_frame_size_t_Encode(&pVal->size_val, pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode data_depth */
	                        ret = asn1SccT_UInt32_Encode(&pVal->data_depth, pBitStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode pixel_size */
	                            ret = asn1SccT_UInt32_Encode(&pVal->pixel_size, pBitStrm, pErrCode, FALSE);
	                            if (ret) {
	                                /*Encode row_size */
	                                ret = asn1SccT_UInt32_Encode(&pVal->row_size, pBitStrm, pErrCode, FALSE);
	                                if (ret) {
	                                    /*Encode frame_mode */
	                                    ret = asn1SccBase_samples_frame_frame_mode_t_Encode(&pVal->frame_mode, pBitStrm, pErrCode, FALSE);
	                                    if (ret) {
	                                        /*Encode frame_status */
	                                        ret = asn1SccBase_samples_frame_frame_status_t_Encode(&pVal->frame_status, pBitStrm, pErrCode, FALSE);
	                                    
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
    }

	return ret;
}

flag asn1SccBase_samples_frame_Frame_Decode(asn1SccBase_samples_frame_Frame* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode time */
	ret = asn1SccBase_Time_Decode(&pVal->time, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode received_time */
	    ret = asn1SccBase_Time_Decode(&pVal->received_time, pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode image */
	        ret = asn1SccBase_samples_frame_Frame_image_Decode(&pVal->image, pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode attributes */
	            ret = asn1SccBase_samples_frame_Frame_attributes_Decode(&pVal->attributes, pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode size_val */
	                ret = asn1SccBase_samples_frame_frame_size_t_Decode(&pVal->size_val, pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode data_depth */
	                    ret = asn1SccT_UInt32_Decode(&pVal->data_depth, pBitStrm, pErrCode);
	                    if (ret) {
	                        /*Decode pixel_size */
	                        ret = asn1SccT_UInt32_Decode(&pVal->pixel_size, pBitStrm, pErrCode);
	                        if (ret) {
	                            /*Decode row_size */
	                            ret = asn1SccT_UInt32_Decode(&pVal->row_size, pBitStrm, pErrCode);
	                            if (ret) {
	                                /*Decode frame_mode */
	                                ret = asn1SccBase_samples_frame_frame_mode_t_Decode(&pVal->frame_mode, pBitStrm, pErrCode);
	                                if (ret) {
	                                    /*Decode frame_status */
	                                    ret = asn1SccBase_samples_frame_frame_status_t_Decode(&pVal->frame_status, pBitStrm, pErrCode);
	                                
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	}


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_frame_FramePair_Initialize(asn1SccBase_samples_frame_FramePair* pVal)
{
    *pVal = (asn1SccBase_samples_frame_FramePair) {
    .time = {
        .microseconds = -9223372036854775807LL
    },
    .first = {
        .time = {
            .microseconds = -9223372036854775807LL
        },
        .received_time = {
            .microseconds = -9223372036854775807LL
        },
        .image = {1,
            {
                0x00
            }
        },
        .attributes = {    .nCount = 1,    .arr = 
            {
                {
                    .data = {0,
                        {
                        }
                    },
                    .name_val = {0,
                        {
                        }
                    }
                }        
            }
        },
        .size_val = {
            .width = 0,
            .height = 0
        },
        .data_depth = 0,
        .pixel_size = 0,
        .row_size = 0,
        .frame_mode = asn1Sccbase_samples_frame_frame_mode_t_compressed_modes,
        .frame_status = asn1Sccbase_samples_frame_frame_status_t_status_empty
    },
    .second = {
        .time = {
            .microseconds = -9223372036854775807LL
        },
        .received_time = {
            .microseconds = -9223372036854775807LL
        },
        .image = {1,
            {
                0x00
            }
        },
        .attributes = {    .nCount = 1,    .arr = 
            {
                {
                    .data = {0,
                        {
                        }
                    },
                    .name_val = {0,
                        {
                        }
                    }
                }        
            }
        },
        .size_val = {
            .width = 0,
            .height = 0
        },
        .data_depth = 0,
        .pixel_size = 0,
        .row_size = 0,
        .frame_mode = asn1Sccbase_samples_frame_frame_mode_t_compressed_modes,
        .frame_status = asn1Sccbase_samples_frame_frame_status_t_status_empty
    },
    .id = 0
};
}
#endif

 
flag asn1SccBase_samples_frame_FramePair_IsConstraintValid(const asn1SccBase_samples_frame_FramePair* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccBase_Time_IsConstraintValid(&pVal->time, pErrCode);
	if (ret) {
	    ret = asn1SccBase_samples_frame_Frame_IsConstraintValid(&pVal->first, pErrCode);
	    if (ret) {
	        ret = asn1SccBase_samples_frame_Frame_IsConstraintValid(&pVal->second, pErrCode);
	        if (ret) {
	            ret = asn1SccT_UInt32_IsConstraintValid(&pVal->id, pErrCode);
	        
	        }
	    }
	}

	return ret;
}

flag asn1SccBase_samples_frame_FramePair_Encode(const asn1SccBase_samples_frame_FramePair* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccBase_samples_frame_FramePair_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode time */
	    ret = asn1SccBase_Time_Encode(&pVal->time, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode first */
	        ret = asn1SccBase_samples_frame_Frame_Encode(&pVal->first, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode second */
	            ret = asn1SccBase_samples_frame_Frame_Encode(&pVal->second, pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode id */
	                ret = asn1SccT_UInt32_Encode(&pVal->id, pBitStrm, pErrCode, FALSE);
	            
	            }
	        }
	    }
    }

	return ret;
}

flag asn1SccBase_samples_frame_FramePair_Decode(asn1SccBase_samples_frame_FramePair* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode time */
	ret = asn1SccBase_Time_Decode(&pVal->time, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode first */
	    ret = asn1SccBase_samples_frame_Frame_Decode(&pVal->first, pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode second */
	        ret = asn1SccBase_samples_frame_Frame_Decode(&pVal->second, pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode id */
	            ret = asn1SccT_UInt32_Decode(&pVal->id, pBitStrm, pErrCode);
	        
	        }
	    }
	}


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_SonarScan_data_Initialize(asn1SccBase_samples_SonarScan_data* pVal)
{
    *pVal = (asn1SccBase_samples_SonarScan_data) {1,
    {
        0x00
    }
};
}
#endif

 
flag asn1SccBase_samples_SonarScan_data_IsConstraintValid(const asn1SccBase_samples_SonarScan_data* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_samples_SonarScan_data);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_samples_SonarScan_data;

	return ret;
}

flag asn1SccBase_samples_SonarScan_data_Encode(const asn1SccBase_samples_SonarScan_data* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? asn1SccBase_samples_SonarScan_data_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	BitStream_AppendByte0(pBitStrm, pVal->arr[i1]);
	    }
    }

	return ret;
}

flag asn1SccBase_samples_SonarScan_data_Decode(asn1SccBase_samples_SonarScan_data* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : 268435529;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = BitStream_ReadByte(pBitStrm, &pVal->arr[i1]); 
		*pErrCode = ret ? 0 : 268435530;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_SonarScan_Initialize(asn1SccBase_samples_SonarScan* pVal)
{
    *pVal = (asn1SccBase_samples_SonarScan) {
    .time = {
        .microseconds = -9223372036854775807LL
    },
    .data = {1,
        {
            0x00
        }
    },
    .time_beams = {    .nCount = 1,    .arr = 
        {
            {
                .microseconds = -9223372036854775807LL
            }        
        }
    },
    .number_of_beams = 0,
    .number_of_bins = 0,
    .start_bearing = {
        .rad = 0.00000000000000000000E+000
    },
    .angular_resolution = {
        .rad = 0.00000000000000000000E+000
    },
    .sampling_interval = 0.00000000000000000000E+000,
    .speed_of_sound = 0.00000000000000000000E+000,
    .beamwidth_horizontal = {
        .rad = 0.00000000000000000000E+000
    },
    .beamwidth_vertical = {
        .rad = 0.00000000000000000000E+000
    },
    .memory_layout_column = FALSE,
    .polar_coordinates = FALSE
};
}
#endif

 
flag asn1SccBase_samples_SonarScan_IsConstraintValid(const asn1SccBase_samples_SonarScan* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccBase_Time_IsConstraintValid(&pVal->time, pErrCode);
	if (ret) {
	    ret = asn1SccBase_samples_SonarScan_data_IsConstraintValid(&pVal->data, pErrCode);
	    if (ret) {
	        ret = asn1SccBase_samples_SonarScan_time_beams_IsConstraintValid(&pVal->time_beams, pErrCode);
	        if (ret) {
	            ret = asn1SccT_UInt16_IsConstraintValid(&pVal->number_of_beams, pErrCode);
	            if (ret) {
	                ret = asn1SccT_UInt16_IsConstraintValid(&pVal->number_of_bins, pErrCode);
	                if (ret) {
	                    ret = asn1SccBase_Angle_IsConstraintValid(&pVal->start_bearing, pErrCode);
	                    if (ret) {
	                        ret = asn1SccBase_Angle_IsConstraintValid(&pVal->angular_resolution, pErrCode);
	                        if (ret) {
	                            ret = asn1SccT_Double_IsConstraintValid(&pVal->sampling_interval, pErrCode);
	                            if (ret) {
	                                ret = asn1SccT_Float_IsConstraintValid(&pVal->speed_of_sound, pErrCode);
	                                if (ret) {
	                                    ret = asn1SccBase_Angle_IsConstraintValid(&pVal->beamwidth_horizontal, pErrCode);
	                                    if (ret) {
	                                        ret = asn1SccBase_Angle_IsConstraintValid(&pVal->beamwidth_vertical, pErrCode);
	                                        if (ret) {
	                                            ret = asn1SccT_Boolean_IsConstraintValid(&pVal->memory_layout_column, pErrCode);
	                                            if (ret) {
	                                                ret = asn1SccT_Boolean_IsConstraintValid(&pVal->polar_coordinates, pErrCode);
	                                            
	                                            }
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

	return ret;
}

flag asn1SccBase_samples_SonarScan_Encode(const asn1SccBase_samples_SonarScan* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccBase_samples_SonarScan_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode time */
	    ret = asn1SccBase_Time_Encode(&pVal->time, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode data */
	        ret = asn1SccBase_samples_SonarScan_data_Encode(&pVal->data, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode time_beams */
	            ret = asn1SccBase_samples_SonarScan_time_beams_Encode(&pVal->time_beams, pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode number_of_beams */
	                ret = asn1SccT_UInt16_Encode(&pVal->number_of_beams, pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode number_of_bins */
	                    ret = asn1SccT_UInt16_Encode(&pVal->number_of_bins, pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode start_bearing */
	                        ret = asn1SccBase_Angle_Encode(&pVal->start_bearing, pBitStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode angular_resolution */
	                            ret = asn1SccBase_Angle_Encode(&pVal->angular_resolution, pBitStrm, pErrCode, FALSE);
	                            if (ret) {
	                                /*Encode sampling_interval */
	                                ret = asn1SccT_Double_Encode(&pVal->sampling_interval, pBitStrm, pErrCode, FALSE);
	                                if (ret) {
	                                    /*Encode speed_of_sound */
	                                    ret = asn1SccT_Float_Encode(&pVal->speed_of_sound, pBitStrm, pErrCode, FALSE);
	                                    if (ret) {
	                                        /*Encode beamwidth_horizontal */
	                                        ret = asn1SccBase_Angle_Encode(&pVal->beamwidth_horizontal, pBitStrm, pErrCode, FALSE);
	                                        if (ret) {
	                                            /*Encode beamwidth_vertical */
	                                            ret = asn1SccBase_Angle_Encode(&pVal->beamwidth_vertical, pBitStrm, pErrCode, FALSE);
	                                            if (ret) {
	                                                /*Encode memory_layout_column */
	                                                ret = asn1SccT_Boolean_Encode(&pVal->memory_layout_column, pBitStrm, pErrCode, FALSE);
	                                                if (ret) {
	                                                    /*Encode polar_coordinates */
	                                                    ret = asn1SccT_Boolean_Encode(&pVal->polar_coordinates, pBitStrm, pErrCode, FALSE);
	                                                
	                                                }
	                                            }
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
    }

	return ret;
}

flag asn1SccBase_samples_SonarScan_Decode(asn1SccBase_samples_SonarScan* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode time */
	ret = asn1SccBase_Time_Decode(&pVal->time, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode data */
	    ret = asn1SccBase_samples_SonarScan_data_Decode(&pVal->data, pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode time_beams */
	        ret = asn1SccBase_samples_SonarScan_time_beams_Decode(&pVal->time_beams, pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode number_of_beams */
	            ret = asn1SccT_UInt16_Decode(&pVal->number_of_beams, pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode number_of_bins */
	                ret = asn1SccT_UInt16_Decode(&pVal->number_of_bins, pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode start_bearing */
	                    ret = asn1SccBase_Angle_Decode(&pVal->start_bearing, pBitStrm, pErrCode);
	                    if (ret) {
	                        /*Decode angular_resolution */
	                        ret = asn1SccBase_Angle_Decode(&pVal->angular_resolution, pBitStrm, pErrCode);
	                        if (ret) {
	                            /*Decode sampling_interval */
	                            ret = asn1SccT_Double_Decode(&pVal->sampling_interval, pBitStrm, pErrCode);
	                            if (ret) {
	                                /*Decode speed_of_sound */
	                                ret = asn1SccT_Float_Decode(&pVal->speed_of_sound, pBitStrm, pErrCode);
	                                if (ret) {
	                                    /*Decode beamwidth_horizontal */
	                                    ret = asn1SccBase_Angle_Decode(&pVal->beamwidth_horizontal, pBitStrm, pErrCode);
	                                    if (ret) {
	                                        /*Decode beamwidth_vertical */
	                                        ret = asn1SccBase_Angle_Decode(&pVal->beamwidth_vertical, pBitStrm, pErrCode);
	                                        if (ret) {
	                                            /*Decode memory_layout_column */
	                                            ret = asn1SccT_Boolean_Decode(&pVal->memory_layout_column, pBitStrm, pErrCode);
	                                            if (ret) {
	                                                /*Decode polar_coordinates */
	                                                ret = asn1SccT_Boolean_Decode(&pVal->polar_coordinates, pBitStrm, pErrCode);
	                                            
	                                            }
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	}


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_SonarBeam_beam_Initialize(asn1SccBase_samples_SonarBeam_beam* pVal)
{
    *pVal = (asn1SccBase_samples_SonarBeam_beam) {1,
    {
        0x00
    }
};
}
#endif

 
flag asn1SccBase_samples_SonarBeam_beam_IsConstraintValid(const asn1SccBase_samples_SonarBeam_beam* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)numBase_samples_SonarBeam_beam);
	*pErrCode = ret ? 0 : ERR_asn1SccBase_samples_SonarBeam_beam;

	return ret;
}

flag asn1SccBase_samples_SonarBeam_beam_Encode(const asn1SccBase_samples_SonarBeam_beam* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? asn1SccBase_samples_SonarBeam_beam_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	BitStream_AppendByte0(pBitStrm, pVal->arr[i1]);
	    }
    }

	return ret;
}

flag asn1SccBase_samples_SonarBeam_beam_Decode(asn1SccBase_samples_SonarBeam_beam* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : 268435531;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = BitStream_ReadByte(pBitStrm, &pVal->arr[i1]); 
		*pErrCode = ret ? 0 : 268435532;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBase_samples_SonarBeam_Initialize(asn1SccBase_samples_SonarBeam* pVal)
{
    *pVal = (asn1SccBase_samples_SonarBeam) {
    .time = {
        .microseconds = -9223372036854775807LL
    },
    .bearing = {
        .rad = 0.00000000000000000000E+000
    },
    .sampling_interval = 0.00000000000000000000E+000,
    .speed_of_sound = 0.00000000000000000000E+000,
    .beamwidth_horizontal = 0.00000000000000000000E+000,
    .beamwidth_vertical = 0.00000000000000000000E+000,
    .beam = {1,
        {
            0x00
        }
    }
};
}
#endif

 
flag asn1SccBase_samples_SonarBeam_IsConstraintValid(const asn1SccBase_samples_SonarBeam* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccBase_Time_IsConstraintValid(&pVal->time, pErrCode);
	if (ret) {
	    ret = asn1SccBase_Angle_IsConstraintValid(&pVal->bearing, pErrCode);
	    if (ret) {
	        ret = asn1SccT_Double_IsConstraintValid(&pVal->sampling_interval, pErrCode);
	        if (ret) {
	            ret = asn1SccT_Float_IsConstraintValid(&pVal->speed_of_sound, pErrCode);
	            if (ret) {
	                ret = asn1SccT_Float_IsConstraintValid(&pVal->beamwidth_horizontal, pErrCode);
	                if (ret) {
	                    ret = asn1SccT_Float_IsConstraintValid(&pVal->beamwidth_vertical, pErrCode);
	                    if (ret) {
	                        ret = asn1SccBase_samples_SonarBeam_beam_IsConstraintValid(&pVal->beam, pErrCode);
	                    
	                    }
	                }
	            }
	        }
	    }
	}

	return ret;
}

flag asn1SccBase_samples_SonarBeam_Encode(const asn1SccBase_samples_SonarBeam* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? asn1SccBase_samples_SonarBeam_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode time */
	    ret = asn1SccBase_Time_Encode(&pVal->time, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode bearing */
	        ret = asn1SccBase_Angle_Encode(&pVal->bearing, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode sampling_interval */
	            ret = asn1SccT_Double_Encode(&pVal->sampling_interval, pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode speed_of_sound */
	                ret = asn1SccT_Float_Encode(&pVal->speed_of_sound, pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode beamwidth_horizontal */
	                    ret = asn1SccT_Float_Encode(&pVal->beamwidth_horizontal, pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode beamwidth_vertical */
	                        ret = asn1SccT_Float_Encode(&pVal->beamwidth_vertical, pBitStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode beam */
	                            ret = asn1SccBase_samples_SonarBeam_beam_Encode(&pVal->beam, pBitStrm, pErrCode, FALSE);
	                        
	                        }
	                    }
	                }
	            }
	        }
	    }
    }

	return ret;
}

flag asn1SccBase_samples_SonarBeam_Decode(asn1SccBase_samples_SonarBeam* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode time */
	ret = asn1SccBase_Time_Decode(&pVal->time, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode bearing */
	    ret = asn1SccBase_Angle_Decode(&pVal->bearing, pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode sampling_interval */
	        ret = asn1SccT_Double_Decode(&pVal->sampling_interval, pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode speed_of_sound */
	            ret = asn1SccT_Float_Decode(&pVal->speed_of_sound, pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode beamwidth_horizontal */
	                ret = asn1SccT_Float_Decode(&pVal->beamwidth_horizontal, pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode beamwidth_vertical */
	                    ret = asn1SccT_Float_Decode(&pVal->beamwidth_vertical, pBitStrm, pErrCode);
	                    if (ret) {
	                        /*Decode beam */
	                        ret = asn1SccBase_samples_SonarBeam_beam_Decode(&pVal->beam, pBitStrm, pErrCode);
	                    
	                    }
	                }
	            }
	        }
	    }
	}


	return ret;
}

